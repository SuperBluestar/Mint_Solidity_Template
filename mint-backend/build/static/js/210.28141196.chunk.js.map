{"version":3,"file":"static/js/210.28141196.chunk.js","mappings":"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","sources":["../node_modules/@ethersproject/basex/lib.esm/index.js","../node_modules/@ethersproject/hash/lib.esm/_version.js","../node_modules/@ethersproject/hash/lib.esm/typed-data.js","../node_modules/@ethersproject/networks/lib.esm/index.js","../node_modules/@ethersproject/networks/lib.esm/_version.js","../node_modules/@ethersproject/strings/lib.esm/idna.js","../node_modules/@ethersproject/hash/lib.esm/namehash.js","../node_modules/@ethersproject/base64/lib.esm/base64.js","../node_modules/@ethersproject/web/lib.esm/_version.js","../node_modules/@ethersproject/web/lib.esm/geturl.js","../node_modules/@ethersproject/web/lib.esm/index.js","../node_modules/@ethersproject/providers/lib.esm/_version.js","../node_modules/@ethersproject/providers/lib.esm/formatter.js","../node_modules/@ethersproject/constants/lib.esm/addresses.js","../node_modules/@ethersproject/providers/lib.esm/base-provider.js","../node_modules/@ethersproject/constants/lib.esm/hashes.js","../node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js","../node_modules/@ethersproject/providers/lib.esm/ws.js","../node_modules/@ethersproject/providers/lib.esm/websocket-provider.js","../node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js","../node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js","../node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js","../node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js","../node_modules/@ethersproject/random/lib.esm/shuffle.js","../node_modules/@ethersproject/providers/lib.esm/fallback-provider.js","../node_modules/@ethersproject/providers/lib.esm/ipc-provider.js","../node_modules/@ethersproject/providers/lib.esm/infura-provider.js","../node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js","../node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js","../node_modules/@ethersproject/providers/lib.esm/pocket-provider.js","../node_modules/@ethersproject/providers/lib.esm/web3-provider.js","../node_modules/@ethersproject/providers/lib.esm/index.js","../node_modules/@ethersproject/sha2/lib.esm/sha2.js","../node_modules/@ethersproject/sha2/lib.esm/_version.js","../node_modules/@ethersproject/sha2/lib.esm/types.js","../node_modules/bech32/index.js"],"sourcesContent":["/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\nimport { arrayify } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nexport class BaseX {\n    constructor(alphabet) {\n        defineReadOnly(this, \"alphabet\", alphabet);\n        defineReadOnly(this, \"base\", alphabet.length);\n        defineReadOnly(this, \"_alphabetMap\", {});\n        defineReadOnly(this, \"_leader\", alphabet.charAt(0));\n        // pre-compute lookup table\n        for (let i = 0; i < alphabet.length; i++) {\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n    encode(value) {\n        let source = arrayify(value);\n        if (source.length === 0) {\n            return \"\";\n        }\n        let digits = [0];\n        for (let i = 0; i < source.length; ++i) {\n            let carry = source[i];\n            for (let j = 0; j < digits.length; ++j) {\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = (carry / this.base) | 0;\n            }\n            while (carry > 0) {\n                digits.push(carry % this.base);\n                carry = (carry / this.base) | 0;\n            }\n        }\n        let string = \"\";\n        // deal with leading zeros\n        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n            string += this._leader;\n        }\n        // convert digits to a string\n        for (let q = digits.length - 1; q >= 0; --q) {\n            string += this.alphabet[digits[q]];\n        }\n        return string;\n    }\n    decode(value) {\n        if (typeof (value) !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n        let bytes = [];\n        if (value.length === 0) {\n            return new Uint8Array(bytes);\n        }\n        bytes.push(0);\n        for (let i = 0; i < value.length; i++) {\n            let byte = this._alphabetMap[value[i]];\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n            let carry = byte;\n            for (let j = 0; j < bytes.length; ++j) {\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n            while (carry > 0) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n        // deal with leading zeros\n        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n            bytes.push(0);\n        }\n        return arrayify(new Uint8Array(bytes.reverse()));\n    }\n}\nconst Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nconst Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\nexport { Base32, Base58 };\n//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n","export const version = \"hash/5.5.0\";\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { id } from \"./id\";\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst NegativeOne = BigNumber.from(-1);\nconst Zero = BigNumber.from(0);\nconst One = BigNumber.from(1);\nconst MaxUint256 = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nfunction hexPadRight(value) {\n    const bytes = arrayify(value);\n    const padOffset = bytes.length % 32;\n    if (padOffset) {\n        return hexConcat([bytes, padding.slice(padOffset)]);\n    }\n    return hexlify(bytes);\n}\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\nconst domainFieldTypes = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\nconst domainFieldNames = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\nfunction checkString(key) {\n    return function (value) {\n        if (typeof (value) !== \"string\") {\n            logger.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n        }\n        return value;\n    };\n}\nconst domainChecks = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function (value) {\n        try {\n            return BigNumber.from(value).toString();\n        }\n        catch (error) { }\n        return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n    },\n    verifyingContract: function (value) {\n        try {\n            return getAddress(value).toLowerCase();\n        }\n        catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function (value) {\n        try {\n            const bytes = arrayify(value);\n            if (bytes.length !== 32) {\n                throw new Error(\"bad length\");\n            }\n            return hexlify(bytes);\n        }\n        catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n    }\n};\nfunction getBaseEncoder(type) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n            const width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\n                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n            const boundsUpper = MaxUint256.mask(signed ? (width - 1) : width);\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;\n            return function (value) {\n                const v = BigNumber.from(value);\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n                    logger.throwArgumentError(`value out-of-bounds for ${type}`, \"value\", value);\n                }\n                return hexZeroPad(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\n                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n            return function (value) {\n                const bytes = arrayify(value);\n                if (bytes.length !== width) {\n                    logger.throwArgumentError(`invalid length for ${type}`, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch (type) {\n        case \"address\": return function (value) {\n            return hexZeroPad(getAddress(value), 32);\n        };\n        case \"bool\": return function (value) {\n            return ((!value) ? hexFalse : hexTrue);\n        };\n        case \"bytes\": return function (value) {\n            return keccak256(value);\n        };\n        case \"string\": return function (value) {\n            return id(value);\n        };\n    }\n    return null;\n}\nfunction encodeType(name, fields) {\n    return `${name}(${fields.map(({ name, type }) => (type + \" \" + name)).join(\",\")})`;\n}\nexport class TypedDataEncoder {\n    constructor(types) {\n        defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n        defineReadOnly(this, \"_encoderCache\", {});\n        defineReadOnly(this, \"_types\", {});\n        // Link struct types to their direct child structs\n        const links = {};\n        // Link structs to structs which contain them as a child\n        const parents = {};\n        // Link all subtypes within a given struct\n        const subtypes = {};\n        Object.keys(types).forEach((type) => {\n            links[type] = {};\n            parents[type] = [];\n            subtypes[type] = {};\n        });\n        for (const name in types) {\n            const uniqueNames = {};\n            types[name].forEach((field) => {\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    logger.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name) {\n                    logger.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, \"types\", types);\n                }\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) {\n                    return;\n                }\n                if (!parents[baseType]) {\n                    logger.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, \"types\", types);\n                }\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));\n        if (primaryTypes.length === 0) {\n            logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        }\n        else if (primaryTypes.length > 1) {\n            logger.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t) => (JSON.stringify(t))).join(\", \")}`, \"types\", types);\n        }\n        defineReadOnly(this, \"primaryType\", primaryTypes[0]);\n        // Check for circular type references\n        function checkCircular(type, found) {\n            if (found[type]) {\n                logger.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, \"types\", types);\n            }\n            found[type] = true;\n            Object.keys(links[type]).forEach((child) => {\n                if (!parents[child]) {\n                    return;\n                }\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype) => {\n                    subtypes[subtype][child] = true;\n                });\n            });\n            delete found[type];\n        }\n        checkCircular(this.primaryType, {});\n        // Compute each fully describe type\n        for (const name in subtypes) {\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\");\n        }\n    }\n    getEncoder(type) {\n        let encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    }\n    _getEncoder(type) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return encoder;\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value) => {\n                if (length >= 0 && value.length !== length) {\n                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) {\n                    result = result.map(keccak256);\n                }\n                return keccak256(hexConcat(result));\n            };\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this._types[type]);\n            return (value) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) {\n                        return keccak256(result);\n                    }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return hexConcat(values);\n            };\n        }\n        return logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n    }\n    encodeType(name) {\n        const result = this._types[name];\n        if (!result) {\n            logger.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, \"name\", name);\n        }\n        return result;\n    }\n    encodeData(type, value) {\n        return this.getEncoder(type)(value);\n    }\n    hashStruct(name, value) {\n        return keccak256(this.encodeData(name, value));\n    }\n    encode(value) {\n        return this.encodeData(this.primaryType, value);\n    }\n    hash(value) {\n        return this.hashStruct(this.primaryType, value);\n    }\n    _visit(type, value, callback) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return callback(type, value);\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (length >= 0 && value.length !== length) {\n                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map((v) => this._visit(subtype, v, callback));\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, {});\n        }\n        return logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n    }\n    visit(value, callback) {\n        return this._visit(this.primaryType, value, callback);\n    }\n    static from(types) {\n        return new TypedDataEncoder(types);\n    }\n    static getPrimaryType(types) {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n    static hashStruct(name, types, value) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    static hashDomain(domain) {\n        const domainFields = [];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            if (!type) {\n                logger.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n            }\n            domainFields.push({ name, type });\n        }\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n    static encode(domain, types, value) {\n        return hexConcat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n    static hash(domain, types, value) {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n    static resolveNames(domain, types, value, resolveName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Make a copy to isolate it from the object passed in\n            domain = shallowCopy(domain);\n            // Look up all ENS names\n            const ensCache = {};\n            // Do we need to look up the domain's verifyingContract?\n            if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n                ensCache[domain.verifyingContract] = \"0x\";\n            }\n            // We are going to use the encoder to visit all the base values\n            const encoder = TypedDataEncoder.from(types);\n            // Get a list of all the addresses\n            encoder.visit(value, (type, value) => {\n                if (type === \"address\" && !isHexString(value, 20)) {\n                    ensCache[value] = \"0x\";\n                }\n                return value;\n            });\n            // Lookup each name\n            for (const name in ensCache) {\n                ensCache[name] = yield resolveName(name);\n            }\n            // Replace the domain verifyingContract if needed\n            if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n                domain.verifyingContract = ensCache[domain.verifyingContract];\n            }\n            // Replace all ENS names with their address\n            value = encoder.visit(value, (type, value) => {\n                if (type === \"address\" && ensCache[value]) {\n                    return ensCache[value];\n                }\n                return value;\n            });\n            return { domain, value };\n        });\n    }\n    static getPayload(domain, types, value) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        const domainValues = {};\n        const domainTypes = [];\n        domainFieldNames.forEach((name) => {\n            const value = domain[name];\n            if (value == null) {\n                return;\n            }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n        const encoder = TypedDataEncoder.from(types);\n        const typesWithDomain = shallowCopy(types);\n        if (typesWithDomain.EIP712Domain) {\n            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        }\n        else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type, value) => {\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(arrayify(value));\n                }\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return BigNumber.from(value).toString();\n                }\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof (value) !== \"string\") {\n                            logger.throwArgumentError(`invalid string`, \"value\", value);\n                        }\n                        return value;\n                }\n                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n","\"use strict\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n;\nfunction isRenetworkable(value) {\n    return (value && typeof (value.renetwork) === \"function\");\n}\nfunction ethDefaultProvider(network) {\n    const func = function (providers, options) {\n        if (options == null) {\n            options = {};\n        }\n        const providerList = [];\n        if (providers.InfuraProvider) {\n            try {\n                providerList.push(new providers.InfuraProvider(network, options.infura));\n            }\n            catch (error) { }\n        }\n        if (providers.EtherscanProvider) {\n            try {\n                providerList.push(new providers.EtherscanProvider(network, options.etherscan));\n            }\n            catch (error) { }\n        }\n        if (providers.AlchemyProvider) {\n            try {\n                providerList.push(new providers.AlchemyProvider(network, options.alchemy));\n            }\n            catch (error) { }\n        }\n        if (providers.PocketProvider) {\n            // These networks are currently faulty on Pocket as their\n            // network does not handle the Berlin hardfork, which is\n            // live on these ones.\n            // @TODO: This goes away once Pocket has upgraded their nodes\n            const skip = [\"goerli\", \"ropsten\", \"rinkeby\"];\n            try {\n                const provider = new providers.PocketProvider(network);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            }\n            catch (error) { }\n        }\n        if (providers.CloudflareProvider) {\n            try {\n                providerList.push(new providers.CloudflareProvider(network));\n            }\n            catch (error) { }\n        }\n        if (providerList.length === 0) {\n            return null;\n        }\n        if (providers.FallbackProvider) {\n            let quorum = 1;\n            if (options.quorum != null) {\n                quorum = options.quorum;\n            }\n            else if (network === \"homestead\") {\n                quorum = 2;\n            }\n            return new providers.FallbackProvider(providerList, quorum);\n        }\n        return providerList[0];\n    };\n    func.renetwork = function (network) {\n        return ethDefaultProvider(network);\n    };\n    return func;\n}\nfunction etcDefaultProvider(url, network) {\n    const func = function (providers, options) {\n        if (providers.JsonRpcProvider) {\n            return new providers.JsonRpcProvider(url, network);\n        }\n        return null;\n    };\n    func.renetwork = function (network) {\n        return etcDefaultProvider(url, network);\n    };\n    return func;\n}\nconst homestead = {\n    chainId: 1,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"homestead\",\n    _defaultProvider: ethDefaultProvider(\"homestead\")\n};\nconst ropsten = {\n    chainId: 3,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"ropsten\",\n    _defaultProvider: ethDefaultProvider(\"ropsten\")\n};\nconst classicMordor = {\n    chainId: 63,\n    name: \"classicMordor\",\n    _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/mordor\", \"classicMordor\")\n};\n// See: https://chainlist.org\nconst networks = {\n    unspecified: { chainId: 0, name: \"unspecified\" },\n    homestead: homestead,\n    mainnet: homestead,\n    morden: { chainId: 2, name: \"morden\" },\n    ropsten: ropsten,\n    testnet: ropsten,\n    rinkeby: {\n        chainId: 4,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"rinkeby\",\n        _defaultProvider: ethDefaultProvider(\"rinkeby\")\n    },\n    kovan: {\n        chainId: 42,\n        name: \"kovan\",\n        _defaultProvider: ethDefaultProvider(\"kovan\")\n    },\n    goerli: {\n        chainId: 5,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"goerli\",\n        _defaultProvider: ethDefaultProvider(\"goerli\")\n    },\n    kintsugi: { chainId: 1337702, name: \"kintsugi\" },\n    // ETC (See: #351)\n    classic: {\n        chainId: 61,\n        name: \"classic\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/etc\", \"classic\")\n    },\n    classicMorden: { chainId: 62, name: \"classicMorden\" },\n    classicMordor: classicMordor,\n    classicTestnet: classicMordor,\n    classicKotti: {\n        chainId: 6,\n        name: \"classicKotti\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/kotti\", \"classicKotti\")\n    },\n    xdai: { chainId: 100, name: \"xdai\" },\n    matic: { chainId: 137, name: \"matic\" },\n    maticmum: { chainId: 80001, name: \"maticmum\" },\n    optimism: { chainId: 10, name: \"optimism\" },\n    \"optimism-kovan\": { chainId: 69, name: \"optimism-kovan\" },\n    \"optimism-goerli\": { chainId: 420, name: \"optimism-goerli\" },\n    arbitrum: { chainId: 42161, name: \"arbitrum\" },\n    \"arbitrum-rinkeby\": { chainId: 421611, name: \"arbitrum-rinkeby\" },\n    bnb: { chainId: 56, name: \"bnb\" },\n    bnbt: { chainId: 97, name: \"bnbt\" },\n};\n/**\n *  getNetwork\n *\n *  Converts a named common networks or chain ID (network ID) to a Network\n *  and verifies a network is a valid Network..\n */\nexport function getNetwork(network) {\n    // No network (null)\n    if (network == null) {\n        return null;\n    }\n    if (typeof (network) === \"number\") {\n        for (const name in networks) {\n            const standard = networks[name];\n            if (standard.chainId === network) {\n                return {\n                    name: standard.name,\n                    chainId: standard.chainId,\n                    ensAddress: (standard.ensAddress || null),\n                    _defaultProvider: (standard._defaultProvider || null)\n                };\n            }\n        }\n        return {\n            chainId: network,\n            name: \"unknown\"\n        };\n    }\n    if (typeof (network) === \"string\") {\n        const standard = networks[network];\n        if (standard == null) {\n            return null;\n        }\n        return {\n            name: standard.name,\n            chainId: standard.chainId,\n            ensAddress: standard.ensAddress,\n            _defaultProvider: (standard._defaultProvider || null)\n        };\n    }\n    const standard = networks[network.name];\n    // Not a standard network; check that it is a valid network in general\n    if (!standard) {\n        if (typeof (network.chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid network chainId\", \"network\", network);\n        }\n        return network;\n    }\n    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\n    if (network.chainId !== 0 && network.chainId !== standard.chainId) {\n        logger.throwArgumentError(\"network chainId mismatch\", \"network\", network);\n    }\n    // @TODO: In the next major version add an attach function to a defaultProvider\n    // class and move the _defaultProvider internal to this file (extend Network)\n    let defaultProvider = network._defaultProvider || null;\n    if (defaultProvider == null && standard._defaultProvider) {\n        if (isRenetworkable(standard._defaultProvider)) {\n            defaultProvider = standard._defaultProvider.renetwork(network);\n        }\n        else {\n            defaultProvider = standard._defaultProvider;\n        }\n    }\n    // Standard Network (allow overriding the ENS address)\n    return {\n        name: network.name,\n        chainId: standard.chainId,\n        ensAddress: (network.ensAddress || standard.ensAddress || null),\n        _defaultProvider: defaultProvider\n    };\n}\n","export const version = \"networks/5.5.2\";\n","\"use strict\";\nimport { toUtf8CodePoints, _toUtf8String, UnicodeNormalizationForm } from \"./utf8\";\nfunction bytes2(data) {\n    if ((data.length % 4) !== 0) {\n        throw new Error(\"bad data\");\n    }\n    let result = [];\n    for (let i = 0; i < data.length; i += 4) {\n        result.push(parseInt(data.substring(i, i + 4), 16));\n    }\n    return result;\n}\nfunction createTable(data, func) {\n    if (!func) {\n        func = function (value) { return [parseInt(value, 16)]; };\n    }\n    let lo = 0;\n    let result = {};\n    data.split(\",\").forEach((pair) => {\n        let comps = pair.split(\":\");\n        lo += parseInt(comps[0], 16);\n        result[lo] = func(comps[1]);\n    });\n    return result;\n}\nfunction createRangeTable(data) {\n    let hi = 0;\n    return data.split(\",\").map((v) => {\n        let comps = v.split(\"-\");\n        if (comps.length === 1) {\n            comps[1] = \"0\";\n        }\n        else if (comps[1] === \"\") {\n            comps[1] = \"1\";\n        }\n        let lo = hi + parseInt(comps[0], 16);\n        hi = parseInt(comps[1], 16);\n        return { l: lo, h: hi };\n    });\n}\nfunction matchMap(value, ranges) {\n    let lo = 0;\n    for (let i = 0; i < ranges.length; i++) {\n        let range = ranges[i];\n        lo += range.l;\n        if (value >= lo && value <= lo + range.h && ((value - lo) % (range.d || 1)) === 0) {\n            if (range.e && range.e.indexOf(value - lo) !== -1) {\n                continue;\n            }\n            return range;\n        }\n    }\n    return null;\n}\nconst Table_A_1_ranges = createRangeTable(\"221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d\");\n// @TODO: Make this relative...\nconst Table_B_1_flags = \"ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff\".split(\",\").map((v) => parseInt(v, 16));\nconst Table_B_2_ranges = [\n    { h: 25, s: 32, l: 65 },\n    { h: 30, s: 32, e: [23], l: 127 },\n    { h: 54, s: 1, e: [48], l: 64, d: 2 },\n    { h: 14, s: 1, l: 57, d: 2 },\n    { h: 44, s: 1, l: 17, d: 2 },\n    { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },\n    { h: 16, s: 1, l: 68, d: 2 },\n    { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },\n    { h: 26, s: 32, e: [17], l: 435 },\n    { h: 22, s: 1, l: 71, d: 2 },\n    { h: 15, s: 80, l: 40 },\n    { h: 31, s: 32, l: 16 },\n    { h: 32, s: 1, l: 80, d: 2 },\n    { h: 52, s: 1, l: 42, d: 2 },\n    { h: 12, s: 1, l: 55, d: 2 },\n    { h: 40, s: 1, e: [38], l: 15, d: 2 },\n    { h: 14, s: 1, l: 48, d: 2 },\n    { h: 37, s: 48, l: 49 },\n    { h: 148, s: 1, l: 6351, d: 2 },\n    { h: 88, s: 1, l: 160, d: 2 },\n    { h: 15, s: 16, l: 704 },\n    { h: 25, s: 26, l: 854 },\n    { h: 25, s: 32, l: 55915 },\n    { h: 37, s: 40, l: 1247 },\n    { h: 25, s: -119711, l: 53248 },\n    { h: 25, s: -119763, l: 52 },\n    { h: 25, s: -119815, l: 52 },\n    { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },\n    { h: 25, s: -119919, l: 52 },\n    { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },\n    { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },\n    { h: 25, s: -120075, l: 52 },\n    { h: 25, s: -120127, l: 52 },\n    { h: 25, s: -120179, l: 52 },\n    { h: 25, s: -120231, l: 52 },\n    { h: 25, s: -120283, l: 52 },\n    { h: 25, s: -120335, l: 52 },\n    { h: 24, s: -119543, e: [17], l: 56 },\n    { h: 24, s: -119601, e: [17], l: 58 },\n    { h: 24, s: -119659, e: [17], l: 58 },\n    { h: 24, s: -119717, e: [17], l: 58 },\n    { h: 24, s: -119775, e: [17], l: 58 }\n];\nconst Table_B_2_lut_abs = createTable(\"b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3\");\nconst Table_B_2_lut_rel = createTable(\"179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7\");\nconst Table_B_2_complex = createTable(\"df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D\", bytes2);\nconst Table_C_ranges = createRangeTable(\"80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001\");\nfunction flatten(values) {\n    return values.reduce((accum, value) => {\n        value.forEach((value) => { accum.push(value); });\n        return accum;\n    }, []);\n}\nexport function _nameprepTableA1(codepoint) {\n    return !!matchMap(codepoint, Table_A_1_ranges);\n}\nexport function _nameprepTableB2(codepoint) {\n    let range = matchMap(codepoint, Table_B_2_ranges);\n    if (range) {\n        return [codepoint + range.s];\n    }\n    let codes = Table_B_2_lut_abs[codepoint];\n    if (codes) {\n        return codes;\n    }\n    let shift = Table_B_2_lut_rel[codepoint];\n    if (shift) {\n        return [codepoint + shift[0]];\n    }\n    let complex = Table_B_2_complex[codepoint];\n    if (complex) {\n        return complex;\n    }\n    return null;\n}\nexport function _nameprepTableC(codepoint) {\n    return !!matchMap(codepoint, Table_C_ranges);\n}\nexport function nameprep(value) {\n    // This allows platforms with incomplete normalize to bypass\n    // it for very basic names which the built-in toLowerCase\n    // will certainly handle correctly\n    if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {\n        return value.toLowerCase();\n    }\n    // Get the code points (keeping the current normalization)\n    let codes = toUtf8CodePoints(value);\n    codes = flatten(codes.map((code) => {\n        // Substitute Table B.1 (Maps to Nothing)\n        if (Table_B_1_flags.indexOf(code) >= 0) {\n            return [];\n        }\n        if (code >= 0xfe00 && code <= 0xfe0f) {\n            return [];\n        }\n        // Substitute Table B.2 (Case Folding)\n        let codesTableB2 = _nameprepTableB2(code);\n        if (codesTableB2) {\n            return codesTableB2;\n        }\n        // No Substitution\n        return [code];\n    }));\n    // Normalize using form KC\n    codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);\n    // Prohibit Tables C.1.2, C.2.2, C.3, C.4, C.5, C.6, C.7, C.8, C.9\n    codes.forEach((code) => {\n        if (_nameprepTableC(code)) {\n            throw new Error(\"STRINGPREP_CONTAINS_PROHIBITED\");\n        }\n    });\n    // Prohibit Unassigned Code Points (Table A.1)\n    codes.forEach((code) => {\n        if (_nameprepTableA1(code)) {\n            throw new Error(\"STRINGPREP_CONTAINS_UNASSIGNED\");\n        }\n    });\n    // IDNA extras\n    let name = _toUtf8String(codes);\n    // IDNA: 4.2.3.1\n    if (name.substring(0, 1) === \"-\" || name.substring(2, 4) === \"--\" || name.substring(name.length - 1) === \"-\") {\n        throw new Error(\"invalid hyphen\");\n    }\n    // IDNA: 4.2.4\n    if (name.length > 63) {\n        throw new Error(\"too long\");\n    }\n    return name;\n}\n","import { concat, hexlify } from \"@ethersproject/bytes\";\nimport { nameprep, toUtf8Bytes } from \"@ethersproject/strings\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nconst Partition = new RegExp(\"^((.*)\\\\.)?([^.]+)$\");\nexport function isValidName(name) {\n    try {\n        const comps = name.split(\".\");\n        for (let i = 0; i < comps.length; i++) {\n            if (nameprep(comps[i]).length === 0) {\n                throw new Error(\"empty\");\n            }\n        }\n        return true;\n    }\n    catch (error) { }\n    return false;\n}\nexport function namehash(name) {\n    /* istanbul ignore if */\n    if (typeof (name) !== \"string\") {\n        logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n    }\n    let current = name;\n    let result = Zeros;\n    while (current.length) {\n        const partition = current.match(Partition);\n        if (partition == null || partition[2] === \"\") {\n            logger.throwArgumentError(\"invalid ENS address; missing component\", \"name\", name);\n        }\n        const label = toUtf8Bytes(nameprep(partition[3]));\n        result = keccak256(concat([result, keccak256(label)]));\n        current = partition[2] || \"\";\n    }\n    return hexlify(result);\n}\n","\"use strict\";\nimport { arrayify } from \"@ethersproject/bytes\";\nexport function decode(textData) {\n    textData = atob(textData);\n    const data = [];\n    for (let i = 0; i < textData.length; i++) {\n        data.push(textData.charCodeAt(i));\n    }\n    return arrayify(data);\n}\nexport function encode(data) {\n    data = arrayify(data);\n    let textData = \"\";\n    for (let i = 0; i < data.length; i++) {\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n}\n","export const version = \"web/5.5.1\";\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { arrayify } from \"@ethersproject/bytes\";\nexport function getUrl(href, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (options == null) {\n            options = {};\n        }\n        const request = {\n            method: (options.method || \"GET\"),\n            headers: (options.headers || {}),\n            body: (options.body || undefined),\n        };\n        if (options.skipFetchSetup !== true) {\n            request.mode = \"cors\"; // no-cors, cors, *same-origin\n            request.cache = \"no-cache\"; // *default, no-cache, reload, force-cache, only-if-cached\n            request.credentials = \"same-origin\"; // include, *same-origin, omit\n            request.redirect = \"follow\"; // manual, *follow, error\n            request.referrer = \"client\"; // no-referrer, *client\n        }\n        ;\n        const response = yield fetch(href, request);\n        const body = yield response.arrayBuffer();\n        const headers = {};\n        if (response.headers.forEach) {\n            response.headers.forEach((value, key) => {\n                headers[key.toLowerCase()] = value;\n            });\n        }\n        else {\n            ((response.headers).keys)().forEach((key) => {\n                headers[key.toLowerCase()] = response.headers.get(key);\n            });\n        }\n        return {\n            headers: headers,\n            statusCode: response.status,\n            statusMessage: response.statusText,\n            body: arrayify(new Uint8Array(body)),\n        };\n    });\n}\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { decode as base64Decode, encode as base64Encode } from \"@ethersproject/base64\";\nimport { hexlify, isBytesLike } from \"@ethersproject/bytes\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { getUrl } from \"./geturl\";\nfunction staller(duration) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\nfunction bodyify(value, type) {\n    if (value == null) {\n        return null;\n    }\n    if (typeof (value) === \"string\") {\n        return value;\n    }\n    if (isBytesLike(value)) {\n        if (type && (type.split(\"/\")[0] === \"text\" || type.split(\";\")[0].trim() === \"application/json\")) {\n            try {\n                return toUtf8String(value);\n            }\n            catch (error) { }\n            ;\n        }\n        return hexlify(value);\n    }\n    return value;\n}\n// This API is still a work in progress; the future changes will likely be:\n// - ConnectionInfo => FetchDataRequest<T = any>\n// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }\n//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)\n// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T\n// For this reason, it should be considered internal until the API is finalized\nexport function _fetchData(connection, body, processFunc) {\n    // How many times to retry in the event of a throttle\n    const attemptLimit = (typeof (connection) === \"object\" && connection.throttleLimit != null) ? connection.throttleLimit : 12;\n    logger.assertArgument((attemptLimit > 0 && (attemptLimit % 1) === 0), \"invalid connection throttle limit\", \"connection.throttleLimit\", attemptLimit);\n    const throttleCallback = ((typeof (connection) === \"object\") ? connection.throttleCallback : null);\n    const throttleSlotInterval = ((typeof (connection) === \"object\" && typeof (connection.throttleSlotInterval) === \"number\") ? connection.throttleSlotInterval : 100);\n    logger.assertArgument((throttleSlotInterval > 0 && (throttleSlotInterval % 1) === 0), \"invalid connection throttle slot interval\", \"connection.throttleSlotInterval\", throttleSlotInterval);\n    const headers = {};\n    let url = null;\n    // @TODO: Allow ConnectionInfo to override some of these values\n    const options = {\n        method: \"GET\",\n    };\n    let allow304 = false;\n    let timeout = 2 * 60 * 1000;\n    if (typeof (connection) === \"string\") {\n        url = connection;\n    }\n    else if (typeof (connection) === \"object\") {\n        if (connection == null || connection.url == null) {\n            logger.throwArgumentError(\"missing URL\", \"connection.url\", connection);\n        }\n        url = connection.url;\n        if (typeof (connection.timeout) === \"number\" && connection.timeout > 0) {\n            timeout = connection.timeout;\n        }\n        if (connection.headers) {\n            for (const key in connection.headers) {\n                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };\n                if ([\"if-none-match\", \"if-modified-since\"].indexOf(key.toLowerCase()) >= 0) {\n                    allow304 = true;\n                }\n            }\n        }\n        options.allowGzip = !!connection.allowGzip;\n        if (connection.user != null && connection.password != null) {\n            if (url.substring(0, 6) !== \"https:\" && connection.allowInsecureAuthentication !== true) {\n                logger.throwError(\"basic authentication requires a secure https url\", Logger.errors.INVALID_ARGUMENT, { argument: \"url\", url: url, user: connection.user, password: \"[REDACTED]\" });\n            }\n            const authorization = connection.user + \":\" + connection.password;\n            headers[\"authorization\"] = {\n                key: \"Authorization\",\n                value: \"Basic \" + base64Encode(toUtf8Bytes(authorization))\n            };\n        }\n    }\n    const reData = new RegExp(\"^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$\", \"i\");\n    const dataMatch = ((url) ? url.match(reData) : null);\n    if (dataMatch) {\n        try {\n            const response = {\n                statusCode: 200,\n                statusMessage: \"OK\",\n                headers: { \"content-type\": dataMatch[1] },\n                body: base64Decode(dataMatch[2])\n            };\n            let result = response.body;\n            if (processFunc) {\n                result = processFunc(response.body, response);\n            }\n            return Promise.resolve(result);\n        }\n        catch (error) {\n            logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                body: bodyify(dataMatch[1], dataMatch[2]),\n                error: error,\n                requestBody: null,\n                requestMethod: \"GET\",\n                url: url\n            });\n        }\n    }\n    if (body) {\n        options.method = \"POST\";\n        options.body = body;\n        if (headers[\"content-type\"] == null) {\n            headers[\"content-type\"] = { key: \"Content-Type\", value: \"application/octet-stream\" };\n        }\n        if (headers[\"content-length\"] == null) {\n            headers[\"content-length\"] = { key: \"Content-Length\", value: String(body.length) };\n        }\n    }\n    const flatHeaders = {};\n    Object.keys(headers).forEach((key) => {\n        const header = headers[key];\n        flatHeaders[header.key] = header.value;\n    });\n    options.headers = flatHeaders;\n    const runningTimeout = (function () {\n        let timer = null;\n        const promise = new Promise(function (resolve, reject) {\n            if (timeout) {\n                timer = setTimeout(() => {\n                    if (timer == null) {\n                        return;\n                    }\n                    timer = null;\n                    reject(logger.makeError(\"timeout\", Logger.errors.TIMEOUT, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        timeout: timeout,\n                        url: url\n                    }));\n                }, timeout);\n            }\n        });\n        const cancel = function () {\n            if (timer == null) {\n                return;\n            }\n            clearTimeout(timer);\n            timer = null;\n        };\n        return { promise, cancel };\n    })();\n    const runningFetch = (function () {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (let attempt = 0; attempt < attemptLimit; attempt++) {\n                let response = null;\n                try {\n                    response = yield getUrl(url, options);\n                    if (attempt < attemptLimit) {\n                        if (response.statusCode === 301 || response.statusCode === 302) {\n                            // Redirection; for now we only support absolute locataions\n                            const location = response.headers.location || \"\";\n                            if (options.method === \"GET\" && location.match(/^https:/)) {\n                                url = response.headers.location;\n                                continue;\n                            }\n                        }\n                        else if (response.statusCode === 429) {\n                            // Exponential back-off throttling\n                            let tryAgain = true;\n                            if (throttleCallback) {\n                                tryAgain = yield throttleCallback(attempt, url);\n                            }\n                            if (tryAgain) {\n                                let stall = 0;\n                                const retryAfter = response.headers[\"retry-after\"];\n                                if (typeof (retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                                    stall = parseInt(retryAfter) * 1000;\n                                }\n                                else {\n                                    stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                                }\n                                //console.log(\"Stalling 429\");\n                                yield staller(stall);\n                                continue;\n                            }\n                        }\n                    }\n                }\n                catch (error) {\n                    response = error.response;\n                    if (response == null) {\n                        runningTimeout.cancel();\n                        logger.throwError(\"missing response\", Logger.errors.SERVER_ERROR, {\n                            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                            requestMethod: options.method,\n                            serverError: error,\n                            url: url\n                        });\n                    }\n                }\n                let body = response.body;\n                if (allow304 && response.statusCode === 304) {\n                    body = null;\n                }\n                else if (response.statusCode < 200 || response.statusCode >= 300) {\n                    runningTimeout.cancel();\n                    logger.throwError(\"bad response\", Logger.errors.SERVER_ERROR, {\n                        status: response.statusCode,\n                        headers: response.headers,\n                        body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"] : null)),\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        url: url\n                    });\n                }\n                if (processFunc) {\n                    try {\n                        const result = yield processFunc(body, response);\n                        runningTimeout.cancel();\n                        return result;\n                    }\n                    catch (error) {\n                        // Allow the processFunc to trigger a throttle\n                        if (error.throttleRetry && attempt < attemptLimit) {\n                            let tryAgain = true;\n                            if (throttleCallback) {\n                                tryAgain = yield throttleCallback(attempt, url);\n                            }\n                            if (tryAgain) {\n                                const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                                //console.log(\"Stalling callback\");\n                                yield staller(timeout);\n                                continue;\n                            }\n                        }\n                        runningTimeout.cancel();\n                        logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                            body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"] : null)),\n                            error: error,\n                            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                            requestMethod: options.method,\n                            url: url\n                        });\n                    }\n                }\n                runningTimeout.cancel();\n                // If we had a processFunc, it either returned a T or threw above.\n                // The \"body\" is now a Uint8Array.\n                return body;\n            }\n            return logger.throwError(\"failed response\", Logger.errors.SERVER_ERROR, {\n                requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                requestMethod: options.method,\n                url: url\n            });\n        });\n    })();\n    return Promise.race([runningTimeout.promise, runningFetch]);\n}\nexport function fetchJson(connection, json, processFunc) {\n    let processJsonFunc = (value, response) => {\n        let result = null;\n        if (value != null) {\n            try {\n                result = JSON.parse(toUtf8String(value));\n            }\n            catch (error) {\n                logger.throwError(\"invalid JSON\", Logger.errors.SERVER_ERROR, {\n                    body: value,\n                    error: error\n                });\n            }\n        }\n        if (processFunc) {\n            result = processFunc(result, response);\n        }\n        return result;\n    };\n    // If we have json to send, we must\n    // - add content-type of application/json (unless already overridden)\n    // - convert the json to bytes\n    let body = null;\n    if (json != null) {\n        body = toUtf8Bytes(json);\n        // Create a connection with the content-type set for JSON\n        const updated = (typeof (connection) === \"string\") ? ({ url: connection }) : shallowCopy(connection);\n        if (updated.headers) {\n            const hasContentType = (Object.keys(updated.headers).filter((k) => (k.toLowerCase() === \"content-type\")).length) !== 0;\n            if (!hasContentType) {\n                updated.headers = shallowCopy(updated.headers);\n                updated.headers[\"content-type\"] = \"application/json\";\n            }\n        }\n        else {\n            updated.headers = { \"content-type\": \"application/json\" };\n        }\n        connection = updated;\n    }\n    return _fetchData(connection, body, processJsonFunc);\n}\nexport function poll(func, options) {\n    if (!options) {\n        options = {};\n    }\n    options = shallowCopy(options);\n    if (options.floor == null) {\n        options.floor = 0;\n    }\n    if (options.ceiling == null) {\n        options.ceiling = 10000;\n    }\n    if (options.interval == null) {\n        options.interval = 250;\n    }\n    return new Promise(function (resolve, reject) {\n        let timer = null;\n        let done = false;\n        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.\n        const cancel = () => {\n            if (done) {\n                return false;\n            }\n            done = true;\n            if (timer) {\n                clearTimeout(timer);\n            }\n            return true;\n        };\n        if (options.timeout) {\n            timer = setTimeout(() => {\n                if (cancel()) {\n                    reject(new Error(\"timeout\"));\n                }\n            }, options.timeout);\n        }\n        const retryLimit = options.retryLimit;\n        let attempt = 0;\n        function check() {\n            return func().then(function (result) {\n                // If we have a result, or are allowed null then we're done\n                if (result !== undefined) {\n                    if (cancel()) {\n                        resolve(result);\n                    }\n                }\n                else if (options.oncePoll) {\n                    options.oncePoll.once(\"poll\", check);\n                }\n                else if (options.onceBlock) {\n                    options.onceBlock.once(\"block\", check);\n                    // Otherwise, exponential back-off (up to 10s) our next request\n                }\n                else if (!done) {\n                    attempt++;\n                    if (attempt > retryLimit) {\n                        if (cancel()) {\n                            reject(new Error(\"retry limit reached\"));\n                        }\n                        return;\n                    }\n                    let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                    if (timeout < options.floor) {\n                        timeout = options.floor;\n                    }\n                    if (timeout > options.ceiling) {\n                        timeout = options.ceiling;\n                    }\n                    setTimeout(check, timeout);\n                }\n                return null;\n            }, function (error) {\n                if (cancel()) {\n                    reject(error);\n                }\n            });\n        }\n        check();\n    });\n}\n","export const version = \"providers/5.5.3\";\n","\"use strict\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexDataLength, hexDataSlice, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { accessListify, parse as parseTransaction } from \"@ethersproject/transactions\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport class Formatter {\n    constructor() {\n        logger.checkNew(new.target, Formatter);\n        this.formats = this.getDefaultFormats();\n    }\n    getDefaultFormats() {\n        const formats = ({});\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n        const strictData = (v) => { return this.data(v, true); };\n        formats.transaction = {\n            hash: hash,\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n            confirmations: Formatter.allowNull(number, null),\n            from: address,\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n            creates: Formatter.allowNull(address, null),\n            raw: Formatter.allowNull(data),\n        };\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n        formats.block = {\n            hash: hash,\n            parentHash: hash,\n            number: number,\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n            miner: address,\n            extraData: data,\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n        formats.blockWithTransactions = shallowCopy(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n            topics: Formatter.arrayOf(hash),\n            transactionHash: hash,\n            logIndex: number,\n        };\n        return formats;\n    }\n    accessList(accessList) {\n        return accessListify(accessList || []);\n    }\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number) {\n        if (number === \"0x\") {\n            return 0;\n        }\n        return BigNumber.from(number).toNumber();\n    }\n    type(number) {\n        if (number === \"0x\" || number == null) {\n            return 0;\n        }\n        return BigNumber.from(number).toNumber();\n    }\n    // Strict! Used on input.\n    bigNumber(value) {\n        return BigNumber.from(value);\n    }\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value) {\n        if (typeof (value) === \"boolean\") {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") {\n                return true;\n            }\n            if (value === \"false\") {\n                return false;\n            }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n    hex(value, strict) {\n        if (typeof (value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") {\n                value = \"0x\" + value;\n            }\n            if (isHexString(value)) {\n                return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n    data(value, strict) {\n        const result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n    // Requires an address\n    // Strict! Used on input.\n    address(value) {\n        return getAddress(value);\n    }\n    callAddress(value) {\n        if (!isHexString(value, 32)) {\n            return null;\n        }\n        const address = getAddress(hexDataSlice(value, 12));\n        return (address === AddressZero) ? null : address;\n    }\n    contractAddress(value) {\n        return getContractAddress(value);\n    }\n    // Strict! Used on input.\n    blockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        if (blockTag === \"earliest\") {\n            return \"0x0\";\n        }\n        if (blockTag === \"latest\" || blockTag === \"pending\") {\n            return blockTag;\n        }\n        if (typeof (blockTag) === \"number\" || isHexString(blockTag)) {\n            return hexValue(blockTag);\n        }\n        throw new Error(\"invalid blockTag\");\n    }\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value, strict) {\n        const result = this.hex(value, strict);\n        if (hexDataLength(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value) {\n        if (value == null) {\n            return null;\n        }\n        const v = BigNumber.from(value);\n        try {\n            return v.toNumber();\n        }\n        catch (error) { }\n        return null;\n    }\n    uint256(value) {\n        if (!isHexString(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return hexZeroPad(value, 32);\n    }\n    _block(value, format) {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = (value._difficulty != null) ? value._difficulty : value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = ((difficulty == null) ? null : BigNumber.from(difficulty));\n        return result;\n    }\n    block(value) {\n        return this._block(value, this.formats.block);\n    }\n    blockWithTransactions(value) {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n    // Strict! Used on input.\n    transactionRequest(value) {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n    transactionResponse(transaction) {\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {\n            transaction.accessList = [];\n        }\n        const result = Formatter.check(this.formats.transaction, transaction);\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n            result.chainId = chainId;\n        }\n        else {\n            let chainId = transaction.networkId;\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n            if (typeof (chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) {\n                    chainId = 0;\n                }\n                chainId = parseInt(chainId);\n            }\n            if (typeof (chainId) !== \"number\") {\n                chainId = 0;\n            }\n            result.chainId = chainId;\n        }\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n        return result;\n    }\n    transaction(value) {\n        return parseTransaction(value);\n    }\n    receiptLog(value) {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n    receipt(value) {\n        const result = Formatter.check(this.formats.receipt, value);\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value)) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value;\n                    delete result.root;\n                }\n                else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            }\n            else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n        return result;\n    }\n    topics(value) {\n        if (Array.isArray(value)) {\n            return value.map((v) => this.topics(v));\n        }\n        else if (value != null) {\n            return this.hash(value, true);\n        }\n        return null;\n    }\n    filter(value) {\n        return Formatter.check(this.formats.filter, value);\n    }\n    filterLog(value) {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n    static check(format, object) {\n        const result = {};\n        for (const key in format) {\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) {\n                    result[key] = value;\n                }\n            }\n            catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n    // if value is null-ish, nullValue is returned\n    static allowNull(format, nullValue) {\n        return (function (value) {\n            if (value == null) {\n                return nullValue;\n            }\n            return format(value);\n        });\n    }\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format, replaceValue) {\n        return (function (value) {\n            if (!value) {\n                return replaceValue;\n            }\n            return format(value);\n        });\n    }\n    // Requires an Array satisfying check\n    static arrayOf(format) {\n        return (function (array) {\n            if (!Array.isArray(array)) {\n                throw new Error(\"not an array\");\n            }\n            const result = [];\n            array.forEach(function (value) {\n                result.push(format(value));\n            });\n            return result;\n        });\n    }\n}\nexport function isCommunityResourcable(value) {\n    return (value && typeof (value.isCommunityResource) === \"function\");\n}\nexport function isCommunityResource(value) {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\n// Show the throttle message only once\nlet throttleMessage = false;\nexport function showThrottleMessage() {\n    if (throttleMessage) {\n        return;\n    }\n    throttleMessage = true;\n    console.log(\"========= NOTICE =========\");\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\n","export const AddressZero = \"0x0000000000000000000000000000000000000000\";\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ForkEvent, Provider } from \"@ethersproject/abstract-provider\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexConcat, hexDataLength, hexDataSlice, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { HashZero } from \"@ethersproject/constants\";\nimport { namehash } from \"@ethersproject/hash\";\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { defineReadOnly, getStatic, resolveProperties } from \"@ethersproject/properties\";\nimport { sha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\nimport bech32 from \"bech32\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { Formatter } from \"./formatter\";\n//////////////////////////////\n// Event Serializeing\nfunction checkTopic(topic) {\n    if (topic == null) {\n        return \"null\";\n    }\n    if (hexDataLength(topic) !== 32) {\n        logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n    }\n    return topic.toLowerCase();\n}\nfunction serializeTopics(topics) {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) {\n        topics.pop();\n    }\n    return topics.map((topic) => {\n        if (Array.isArray(topic)) {\n            // Only track unique OR-topics\n            const unique = {};\n            topic.forEach((topic) => {\n                unique[checkTopic(topic)] = true;\n            });\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n            return sorted.join(\"|\");\n        }\n        else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\nfunction deserializeTopics(data) {\n    if (data === \"\") {\n        return [];\n    }\n    return data.split(/&/g).map((topic) => {\n        if (topic === \"\") {\n            return [];\n        }\n        const comps = topic.split(\"|\").map((topic) => {\n            return ((topic === \"null\") ? null : topic);\n        });\n        return ((comps.length === 1) ? comps[0] : comps);\n    });\n}\nfunction getEventTag(eventName) {\n    if (typeof (eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n        if (hexDataLength(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n    }\n    else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n    }\n    else if (ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n    }\n    else if (eventName && typeof (eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n    throw new Error(\"invalid event - \" + eventName);\n}\n//////////////////////////////\n// Helper Object\nfunction getTime() {\n    return (new Date()).getTime();\n}\nfunction stall(duration) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n//////////////////////////////\n// Provider Object\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\nconst PollableEvents = [\"block\", \"network\", \"pending\", \"poll\"];\nexport class Event {\n    constructor(tag, listener, once) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"listener\", listener);\n        defineReadOnly(this, \"once\", once);\n    }\n    get event() {\n        switch (this.type) {\n            case \"tx\":\n                return this.hash;\n            case \"filter\":\n                return this.filter;\n        }\n        return this.tag;\n    }\n    get type() {\n        return this.tag.split(\":\")[0];\n    }\n    get hash() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") {\n            return null;\n        }\n        return comps[1];\n    }\n    get filter() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") {\n            return null;\n        }\n        const address = comps[1];\n        const topics = deserializeTopics(comps[2]);\n        const filter = {};\n        if (topics.length > 0) {\n            filter.topics = topics;\n        }\n        if (address && address !== \"*\") {\n            filter.address = address;\n        }\n        return filter;\n    }\n    pollable() {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    }\n}\n;\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos = {\n    \"0\": { symbol: \"btc\", p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\": { symbol: \"ltc\", p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\": { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\": { symbol: \"eth\", ilk: \"eth\" },\n    \"61\": { symbol: \"etc\", ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\nfunction bytes32ify(value) {\n    return hexZeroPad(BigNumber.from(value).toHexString(), 32);\n}\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data) {\n    return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));\n}\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\nfunction _parseString(result) {\n    try {\n        return toUtf8String(_parseBytes(result));\n    }\n    catch (error) { }\n    return null;\n}\nfunction _parseBytes(result) {\n    if (result === \"0x\") {\n        return null;\n    }\n    const offset = BigNumber.from(hexDataSlice(result, 0, 32)).toNumber();\n    const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();\n    return hexDataSlice(result, offset + 32, offset + 32 + length);\n}\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    }\n    else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    }\n    else {\n        logger.throwArgumentError(\"unsupported IPFS format\", \"link\", link);\n    }\n    return `https:/\\/gateway.ipfs.io/ipfs/${link}`;\n}\nexport class Resolver {\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider, address, name, resolvedAddress) {\n        defineReadOnly(this, \"provider\", provider);\n        defineReadOnly(this, \"name\", name);\n        defineReadOnly(this, \"address\", provider.formatter.address(address));\n        defineReadOnly(this, \"_resolvedAddress\", resolvedAddress);\n    }\n    _fetchBytes(selector, parameters) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // e.g. keccak256(\"addr(bytes32,uint256)\")\n            const tx = {\n                to: this.address,\n                data: hexConcat([selector, namehash(this.name), (parameters || \"0x\")])\n            };\n            try {\n                return _parseBytes(yield this.provider.call(tx));\n            }\n            catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                return null;\n            }\n        });\n    }\n    _getAddress(coinType, hexBytes) {\n        const coinInfo = coinInfos[String(coinType)];\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${coinType})`\n            });\n        }\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n        const bytes = arrayify(hexBytes);\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([[coinInfo.p2pkh], (\"0x\" + p2pkh[2])]));\n                }\n            }\n        }\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([[coinInfo.p2sh], (\"0x\" + p2sh[2])]));\n                }\n            }\n        }\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            }\n            else {\n                version = -1;\n            }\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32.toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32.encode(coinInfo.prefix, words);\n            }\n        }\n        return null;\n    }\n    getAddress(coinType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (coinType == null) {\n                coinType = 60;\n            }\n            // If Ethereum, use the standard `addr(bytes32)`\n            if (coinType === 60) {\n                try {\n                    // keccak256(\"addr(bytes32)\")\n                    const transaction = {\n                        to: this.address,\n                        data: (\"0x3b3b57de\" + namehash(this.name).substring(2))\n                    };\n                    const hexBytes = yield this.provider.call(transaction);\n                    // No address\n                    if (hexBytes === \"0x\" || hexBytes === HashZero) {\n                        return null;\n                    }\n                    return this.provider.formatter.callAddress(hexBytes);\n                }\n                catch (error) {\n                    if (error.code === Logger.errors.CALL_EXCEPTION) {\n                        return null;\n                    }\n                    throw error;\n                }\n            }\n            // keccak256(\"addr(bytes32,uint256\")\n            const hexBytes = yield this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n            // No address\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // Compute the address\n            const address = this._getAddress(coinType, hexBytes);\n            if (address == null) {\n                logger.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `getAddress(${coinType})`,\n                    coinType: coinType,\n                    data: hexBytes\n                });\n            }\n            return address;\n        });\n    }\n    getAvatar() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const linkage = [{ type: \"name\", content: this.name }];\n            try {\n                // test data for ricmoo.eth\n                //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n                const avatar = yield this.getText(\"avatar\");\n                if (avatar == null) {\n                    return null;\n                }\n                for (let i = 0; i < matchers.length; i++) {\n                    const match = avatar.match(matchers[i]);\n                    if (match == null) {\n                        continue;\n                    }\n                    const scheme = match[1].toLowerCase();\n                    switch (scheme) {\n                        case \"https\":\n                            linkage.push({ type: \"url\", content: avatar });\n                            return { linkage, url: avatar };\n                        case \"data\":\n                            linkage.push({ type: \"data\", content: avatar });\n                            return { linkage, url: avatar };\n                        case \"ipfs\":\n                            linkage.push({ type: \"ipfs\", content: avatar });\n                            return { linkage, url: getIpfsLink(avatar) };\n                        case \"erc721\":\n                        case \"erc1155\": {\n                            // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                            const selector = (scheme === \"erc721\") ? \"0xc87b56dd\" : \"0x0e89341c\";\n                            linkage.push({ type: scheme, content: avatar });\n                            // The owner of this name\n                            const owner = (this._resolvedAddress || (yield this.getAddress()));\n                            const comps = (match[2] || \"\").split(\"/\");\n                            if (comps.length !== 2) {\n                                return null;\n                            }\n                            const addr = yield this.provider.formatter.address(comps[0]);\n                            const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);\n                            // Check that this account owns the token\n                            if (scheme === \"erc721\") {\n                                // ownerOf(uint256 tokenId)\n                                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({\n                                    to: addr, data: hexConcat([\"0x6352211e\", tokenId])\n                                }));\n                                if (owner !== tokenOwner) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"owner\", content: tokenOwner });\n                            }\n                            else if (scheme === \"erc1155\") {\n                                // balanceOf(address owner, uint256 tokenId)\n                                const balance = BigNumber.from(yield this.provider.call({\n                                    to: addr, data: hexConcat([\"0x00fdd58e\", hexZeroPad(owner, 32), tokenId])\n                                }));\n                                if (balance.isZero()) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"balance\", content: balance.toString() });\n                            }\n                            // Call the token contract for the metadata URL\n                            const tx = {\n                                to: this.provider.formatter.address(comps[0]),\n                                data: hexConcat([selector, tokenId])\n                            };\n                            let metadataUrl = _parseString(yield this.provider.call(tx));\n                            if (metadataUrl == null) {\n                                return null;\n                            }\n                            linkage.push({ type: \"metadata-url-base\", content: metadataUrl });\n                            // ERC-1155 allows a generic {id} in the URL\n                            if (scheme === \"erc1155\") {\n                                metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                                linkage.push({ type: \"metadata-url-expanded\", content: metadataUrl });\n                            }\n                            // Transform IPFS metadata links\n                            if (metadataUrl.match(/^ipfs:/i)) {\n                                metadataUrl = getIpfsLink(metadataUrl);\n                            }\n                            linkage.push({ type: \"metadata-url\", content: metadataUrl });\n                            // Get the token metadata\n                            const metadata = yield fetchJson(metadataUrl);\n                            if (!metadata) {\n                                return null;\n                            }\n                            linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n                            // Pull the image URL out\n                            let imageUrl = metadata.image;\n                            if (typeof (imageUrl) !== \"string\") {\n                                return null;\n                            }\n                            if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                                // Allow\n                            }\n                            else {\n                                // Transform IPFS link to gateway\n                                const ipfs = imageUrl.match(matcherIpfs);\n                                if (ipfs == null) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"url-ipfs\", content: imageUrl });\n                                imageUrl = getIpfsLink(imageUrl);\n                            }\n                            linkage.push({ type: \"url\", content: imageUrl });\n                            return { linkage, url: imageUrl };\n                        }\n                    }\n                }\n            }\n            catch (error) { }\n            return null;\n        });\n    }\n    getContentHash() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // keccak256(\"contenthash()\")\n            const hexBytes = yield this._fetchBytes(\"0xbc1c58d1\");\n            // No contenthash\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // IPFS (CID: 1, Type: DAG-PB)\n            const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipfs) {\n                const length = parseInt(ipfs[3], 16);\n                if (ipfs[4].length === length * 2) {\n                    return \"ipfs:/\\/\" + Base58.encode(\"0x\" + ipfs[1]);\n                }\n            }\n            // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n            const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n            if (swarm) {\n                if (swarm[1].length === (32 * 2)) {\n                    return \"bzz:/\\/\" + swarm[1];\n                }\n            }\n            return logger.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"getContentHash()\",\n                data: hexBytes\n            });\n        });\n    }\n    getText(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // The key encoded as parameter to fetchBytes\n            let keyBytes = toUtf8Bytes(key);\n            // The nodehash consumes the first slot, so the string pointer targets\n            // offset 64, with the length at offset 64 and data starting at offset 96\n            keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);\n            // Pad to word-size (32 bytes)\n            if ((keyBytes.length % 32) !== 0) {\n                keyBytes = concat([keyBytes, hexZeroPad(\"0x\", 32 - (key.length % 32))]);\n            }\n            const hexBytes = yield this._fetchBytes(\"0x59d1d43c\", hexlify(keyBytes));\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            return toUtf8String(hexBytes);\n        });\n    }\n}\nlet defaultFormatter = null;\nlet nextPollId = 1;\nexport class BaseProvider extends Provider {\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n    constructor(network) {\n        logger.checkNew(new.target, Provider);\n        super();\n        // Events being listened to\n        this._events = [];\n        this._emitted = { block: -2 };\n        this.formatter = new.target.getFormatter();\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        defineReadOnly(this, \"anyNetwork\", (network === \"any\"));\n        if (this.anyNetwork) {\n            network = this.detectNetwork();\n        }\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error) => { });\n            // Trigger initial network setting (async)\n            this._ready().catch((error) => { });\n        }\n        else {\n            const knownNetwork = getStatic(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                defineReadOnly(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n            }\n            else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n        this._maxInternalBlockNumber = -1024;\n        this._lastBlockNumber = -2;\n        this._pollingInterval = 4000;\n        this._fastQueryDate = 0;\n    }\n    _ready() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._network == null) {\n                let network = null;\n                if (this._networkPromise) {\n                    try {\n                        network = yield this._networkPromise;\n                    }\n                    catch (error) { }\n                }\n                // Try the Provider's network detection (this MUST throw if it cannot)\n                if (network == null) {\n                    network = yield this.detectNetwork();\n                }\n                // This should never happen; every Provider sub-class should have\n                // suggested a network by here (or have thrown).\n                if (!network) {\n                    logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // Possible this call stacked so do not call defineReadOnly again\n                if (this._network == null) {\n                    if (this.anyNetwork) {\n                        this._network = network;\n                    }\n                    else {\n                        defineReadOnly(this, \"_network\", network);\n                    }\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return this._network;\n        });\n    }\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready() {\n        return poll(() => {\n            return this._ready().then((network) => {\n                return network;\n            }, (error) => {\n                // If the network isn't running yet, we will wait\n                if (error.code === Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter() {\n        if (defaultFormatter == null) {\n            defaultFormatter = new Formatter();\n        }\n        return defaultFormatter;\n    }\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network) {\n        return getNetwork((network == null) ? \"homestead\" : network);\n    }\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    _getInternalBlockNumber(maxAge) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._ready();\n            // Allowing stale data up to maxAge old\n            if (maxAge > 0) {\n                // While there are pending internal block requests...\n                while (this._internalBlockNumber) {\n                    // ...\"remember\" which fetch we started with\n                    const internalBlockNumber = this._internalBlockNumber;\n                    try {\n                        // Check the result is not too stale\n                        const result = yield internalBlockNumber;\n                        if ((getTime() - result.respTime) <= maxAge) {\n                            return result.blockNumber;\n                        }\n                        // Too old; fetch a new value\n                        break;\n                    }\n                    catch (error) {\n                        // The fetch rejected; if we are the first to get the\n                        // rejection, drop through so we replace it with a new\n                        // fetch; all others blocked will then get that fetch\n                        // which won't match the one they \"remembered\" and loop\n                        if (this._internalBlockNumber === internalBlockNumber) {\n                            break;\n                        }\n                    }\n                }\n            }\n            const reqTime = getTime();\n            const checkInternalBlockNumber = resolveProperties({\n                blockNumber: this.perform(\"getBlockNumber\", {}),\n                networkError: this.getNetwork().then((network) => (null), (error) => (error))\n            }).then(({ blockNumber, networkError }) => {\n                if (networkError) {\n                    // Unremember this bad internal block number\n                    if (this._internalBlockNumber === checkInternalBlockNumber) {\n                        this._internalBlockNumber = null;\n                    }\n                    throw networkError;\n                }\n                const respTime = getTime();\n                blockNumber = BigNumber.from(blockNumber).toNumber();\n                if (blockNumber < this._maxInternalBlockNumber) {\n                    blockNumber = this._maxInternalBlockNumber;\n                }\n                this._maxInternalBlockNumber = blockNumber;\n                this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n                return { blockNumber, reqTime, respTime };\n            });\n            this._internalBlockNumber = checkInternalBlockNumber;\n            // Swallow unhandled exceptions; if needed they are handled else where\n            checkInternalBlockNumber.catch((error) => {\n                // Don't null the dead (rejected) fetch, if it has already been updated\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n            });\n            return (yield checkInternalBlockNumber).blockNumber;\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const pollId = nextPollId++;\n            // Track all running promises, so we can trigger a post-poll once they are complete\n            const runners = [];\n            let blockNumber = null;\n            try {\n                blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n            }\n            catch (error) {\n                this.emit(\"error\", error);\n                return;\n            }\n            this._setFastBlockNumber(blockNumber);\n            // Emit a poll event after we have the latest (fast) block number\n            this.emit(\"poll\", pollId, blockNumber);\n            // If the block has not changed, meh.\n            if (blockNumber === this._lastBlockNumber) {\n                this.emit(\"didPoll\", pollId);\n                return;\n            }\n            // First polling cycle, trigger a \"block\" events\n            if (this._emitted.block === -2) {\n                this._emitted.block = blockNumber - 1;\n            }\n            if (Math.abs((this._emitted.block) - blockNumber) > 1000) {\n                logger.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);\n                this.emit(\"error\", logger.makeError(\"network block skew detected\", Logger.errors.NETWORK_ERROR, {\n                    blockNumber: blockNumber,\n                    event: \"blockSkew\",\n                    previousBlockNumber: this._emitted.block\n                }));\n                this.emit(\"block\", blockNumber);\n            }\n            else {\n                // Notify all listener for each block that has passed\n                for (let i = this._emitted.block + 1; i <= blockNumber; i++) {\n                    this.emit(\"block\", i);\n                }\n            }\n            // The emitted block was updated, check for obsolete events\n            if (this._emitted.block !== blockNumber) {\n                this._emitted.block = blockNumber;\n                Object.keys(this._emitted).forEach((key) => {\n                    // The block event does not expire\n                    if (key === \"block\") {\n                        return;\n                    }\n                    // The block we were at when we emitted this event\n                    const eventBlockNumber = this._emitted[key];\n                    // We cannot garbage collect pending transactions or blocks here\n                    // They should be garbage collected by the Provider when setting\n                    // \"pending\" events\n                    if (eventBlockNumber === \"pending\") {\n                        return;\n                    }\n                    // Evict any transaction hashes or block hashes over 12 blocks\n                    // old, since they should not return null anyways\n                    if (blockNumber - eventBlockNumber > 12) {\n                        delete this._emitted[key];\n                    }\n                });\n            }\n            // First polling cycle\n            if (this._lastBlockNumber === -2) {\n                this._lastBlockNumber = blockNumber - 1;\n            }\n            // Find all transaction hashes we are waiting on\n            this._events.forEach((event) => {\n                switch (event.type) {\n                    case \"tx\": {\n                        const hash = event.hash;\n                        let runner = this.getTransactionReceipt(hash).then((receipt) => {\n                            if (!receipt || receipt.blockNumber == null) {\n                                return null;\n                            }\n                            this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                            this.emit(hash, receipt);\n                            return null;\n                        }).catch((error) => { this.emit(\"error\", error); });\n                        runners.push(runner);\n                        break;\n                    }\n                    case \"filter\": {\n                        const filter = event.filter;\n                        filter.fromBlock = this._lastBlockNumber + 1;\n                        filter.toBlock = blockNumber;\n                        const runner = this.getLogs(filter).then((logs) => {\n                            if (logs.length === 0) {\n                                return;\n                            }\n                            logs.forEach((log) => {\n                                this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                                this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n                                this.emit(filter, log);\n                            });\n                        }).catch((error) => { this.emit(\"error\", error); });\n                        runners.push(runner);\n                        break;\n                    }\n                }\n            });\n            this._lastBlockNumber = blockNumber;\n            // Once all events for this loop have been processed, emit \"didPoll\"\n            Promise.all(runners).then(() => {\n                this.emit(\"didPoll\", pollId);\n            }).catch((error) => { this.emit(\"error\", error); });\n            return;\n        });\n    }\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber) {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) {\n            this.poll();\n        }\n    }\n    get network() {\n        return this._network;\n    }\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return logger.throwError(\"provider does not support network detection\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"provider.detectNetwork\"\n            });\n        });\n    }\n    getNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const network = yield this._ready();\n            // Make sure we are still connected to the same network; this is\n            // only an external call for backends which can have the underlying\n            // network change spontaneously\n            const currentNetwork = yield this.detectNetwork();\n            if (network.chainId !== currentNetwork.chainId) {\n                // We are allowing network changes, things can get complex fast;\n                // make sure you know what you are doing if you use \"any\"\n                if (this.anyNetwork) {\n                    this._network = currentNetwork;\n                    // Reset all internal block number guards and caches\n                    this._lastBlockNumber = -2;\n                    this._fastBlockNumber = null;\n                    this._fastBlockNumberPromise = null;\n                    this._fastQueryDate = 0;\n                    this._emitted.block = -2;\n                    this._maxInternalBlockNumber = -1024;\n                    this._internalBlockNumber = null;\n                    // The \"network\" event MUST happen before this method resolves\n                    // so any events have a chance to unregister, so we stall an\n                    // additional event loop before returning from /this/ call\n                    this.emit(\"network\", currentNetwork, network);\n                    yield stall(0);\n                    return this._network;\n                }\n                const error = logger.makeError(\"underlying network changed\", Logger.errors.NETWORK_ERROR, {\n                    event: \"changed\",\n                    network: network,\n                    detectedNetwork: currentNetwork\n                });\n                this.emit(\"error\", error);\n                throw error;\n            }\n            return network;\n        });\n    }\n    get blockNumber() {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {\n            this._setFastBlockNumber(blockNumber);\n        }, (error) => { });\n        return (this._fastBlockNumber != null) ? this._fastBlockNumber : -1;\n    }\n    get polling() {\n        return (this._poller != null);\n    }\n    set polling(value) {\n        if (value && !this._poller) {\n            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(() => {\n                    this.poll();\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(() => {\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) {\n                            this.poll();\n                        }\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n        }\n        else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n    get pollingInterval() {\n        return this._pollingInterval;\n    }\n    set pollingInterval(value) {\n        if (typeof (value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n        this._pollingInterval = value;\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);\n        }\n    }\n    _getFastBlockNumber() {\n        const now = getTime();\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n        return this._fastBlockNumberPromise;\n    }\n    _setFastBlockNumber(blockNumber) {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {\n            return;\n        }\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n    waitForTransaction(transactionHash, confirmations, timeout) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._waitForTransaction(transactionHash, (confirmations == null) ? 1 : confirmations, timeout || 0, null);\n        });\n    }\n    _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const receipt = yield this.getTransactionReceipt(transactionHash);\n            // Receipt is already good\n            if ((receipt ? receipt.confirmations : 0) >= confirmations) {\n                return receipt;\n            }\n            // Poll until the receipt is good...\n            return new Promise((resolve, reject) => {\n                const cancelFuncs = [];\n                let done = false;\n                const alreadyDone = function () {\n                    if (done) {\n                        return true;\n                    }\n                    done = true;\n                    cancelFuncs.forEach((func) => { func(); });\n                    return false;\n                };\n                const minedHandler = (receipt) => {\n                    if (receipt.confirmations < confirmations) {\n                        return;\n                    }\n                    if (alreadyDone()) {\n                        return;\n                    }\n                    resolve(receipt);\n                };\n                this.on(transactionHash, minedHandler);\n                cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });\n                if (replaceable) {\n                    let lastBlockNumber = replaceable.startBlock;\n                    let scannedBlock = null;\n                    const replaceHandler = (blockNumber) => __awaiter(this, void 0, void 0, function* () {\n                        if (done) {\n                            return;\n                        }\n                        // Wait 1 second; this is only used in the case of a fault, so\n                        // we will trade off a little bit of latency for more consistent\n                        // results and fewer JSON-RPC calls\n                        yield stall(1000);\n                        this.getTransactionCount(replaceable.from).then((nonce) => __awaiter(this, void 0, void 0, function* () {\n                            if (done) {\n                                return;\n                            }\n                            if (nonce <= replaceable.nonce) {\n                                lastBlockNumber = blockNumber;\n                            }\n                            else {\n                                // First check if the transaction was mined\n                                {\n                                    const mined = yield this.getTransaction(transactionHash);\n                                    if (mined && mined.blockNumber != null) {\n                                        return;\n                                    }\n                                }\n                                // First time scanning. We start a little earlier for some\n                                // wiggle room here to handle the eventually consistent nature\n                                // of blockchain (e.g. the getTransactionCount was for a\n                                // different block)\n                                if (scannedBlock == null) {\n                                    scannedBlock = lastBlockNumber - 3;\n                                    if (scannedBlock < replaceable.startBlock) {\n                                        scannedBlock = replaceable.startBlock;\n                                    }\n                                }\n                                while (scannedBlock <= blockNumber) {\n                                    if (done) {\n                                        return;\n                                    }\n                                    const block = yield this.getBlockWithTransactions(scannedBlock);\n                                    for (let ti = 0; ti < block.transactions.length; ti++) {\n                                        const tx = block.transactions[ti];\n                                        // Successfully mined!\n                                        if (tx.hash === transactionHash) {\n                                            return;\n                                        }\n                                        // Matches our transaction from and nonce; its a replacement\n                                        if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                            if (done) {\n                                                return;\n                                            }\n                                            // Get the receipt of the replacement\n                                            const receipt = yield this.waitForTransaction(tx.hash, confirmations);\n                                            // Already resolved or rejected (prolly a timeout)\n                                            if (alreadyDone()) {\n                                                return;\n                                            }\n                                            // The reason we were replaced\n                                            let reason = \"replaced\";\n                                            if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                                reason = \"repriced\";\n                                            }\n                                            else if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                                reason = \"cancelled\";\n                                            }\n                                            // Explain why we were replaced\n                                            reject(logger.makeError(\"transaction was replaced\", Logger.errors.TRANSACTION_REPLACED, {\n                                                cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                                reason,\n                                                replacement: this._wrapTransaction(tx),\n                                                hash: transactionHash,\n                                                receipt\n                                            }));\n                                            return;\n                                        }\n                                    }\n                                    scannedBlock++;\n                                }\n                            }\n                            if (done) {\n                                return;\n                            }\n                            this.once(\"block\", replaceHandler);\n                        }), (error) => {\n                            if (done) {\n                                return;\n                            }\n                            this.once(\"block\", replaceHandler);\n                        });\n                    });\n                    if (done) {\n                        return;\n                    }\n                    this.once(\"block\", replaceHandler);\n                    cancelFuncs.push(() => {\n                        this.removeListener(\"block\", replaceHandler);\n                    });\n                }\n                if (typeof (timeout) === \"number\" && timeout > 0) {\n                    const timer = setTimeout(() => {\n                        if (alreadyDone()) {\n                            return;\n                        }\n                        reject(logger.makeError(\"timeout exceeded\", Logger.errors.TIMEOUT, { timeout: timeout }));\n                    }, timeout);\n                    if (timer.unref) {\n                        timer.unref();\n                    }\n                    cancelFuncs.push(() => { clearTimeout(timer); });\n                }\n            });\n        });\n    }\n    getBlockNumber() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._getInternalBlockNumber(0);\n        });\n    }\n    getGasPrice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const result = yield this.perform(\"getGasPrice\", {});\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getGasPrice\",\n                    result, error\n                });\n            }\n        });\n    }\n    getBalance(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getBalance\", params);\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getBalance\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getTransactionCount(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getTransactionCount\", params);\n            try {\n                return BigNumber.from(result).toNumber();\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getTransactionCount\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getCode(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getCode\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getCode\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getStorageAt(addressOrName, position, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag),\n                position: Promise.resolve(position).then((p) => hexValue(p))\n            });\n            const result = yield this.perform(\"getStorageAt\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getStorageAt\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx, hash, startBlock) {\n        if (hash != null && hexDataLength(hash) !== 32) {\n            throw new Error(\"invalid response - sendTransaction\");\n        }\n        const result = tx;\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n        result.wait = (confirms, timeout) => __awaiter(this, void 0, void 0, function* () {\n            if (confirms == null) {\n                confirms = 1;\n            }\n            if (timeout == null) {\n                timeout = 0;\n            }\n            // Get the details to detect replacement\n            let replacement = undefined;\n            if (confirms !== 0 && startBlock != null) {\n                replacement = {\n                    data: tx.data,\n                    from: tx.from,\n                    nonce: tx.nonce,\n                    to: tx.to,\n                    value: tx.value,\n                    startBlock\n                };\n            }\n            const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n            if (receipt == null && confirms === 0) {\n                return null;\n            }\n            // No longer pending, allow the polling loop to garbage collect this\n            this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n            if (receipt.status === 0) {\n                logger.throwError(\"transaction failed\", Logger.errors.CALL_EXCEPTION, {\n                    transactionHash: tx.hash,\n                    transaction: tx,\n                    receipt: receipt\n                });\n            }\n            return receipt;\n        });\n        return result;\n    }\n    sendTransaction(signedTransaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const hexTx = yield Promise.resolve(signedTransaction).then(t => hexlify(t));\n            const tx = this.formatter.transaction(signedTransaction);\n            if (tx.confirmations == null) {\n                tx.confirmations = 0;\n            }\n            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            try {\n                const hash = yield this.perform(\"sendTransaction\", { signedTransaction: hexTx });\n                return this._wrapTransaction(tx, hash, blockNumber);\n            }\n            catch (error) {\n                error.transaction = tx;\n                error.transactionHash = tx.hash;\n                throw error;\n            }\n        });\n    }\n    _getTransactionRequest(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const values = yield transaction;\n            const tx = {};\n            [\"from\", \"to\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v) : null));\n            });\n            [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? BigNumber.from(v) : null));\n            });\n            [\"type\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v : null));\n            });\n            if (values.accessList) {\n                tx.accessList = this.formatter.accessList(values.accessList);\n            }\n            [\"data\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? hexlify(v) : null));\n            });\n            return this.formatter.transactionRequest(yield resolveProperties(tx));\n        });\n    }\n    _getFilter(filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            filter = yield filter;\n            const result = {};\n            if (filter.address != null) {\n                result.address = this._getAddress(filter.address);\n            }\n            [\"blockHash\", \"topics\"].forEach((key) => {\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = filter[key];\n            });\n            [\"fromBlock\", \"toBlock\"].forEach((key) => {\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = this._getBlockTag(filter[key]);\n            });\n            return this.formatter.filter(yield resolveProperties(result));\n        });\n    }\n    call(transaction, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                transaction: this._getTransactionRequest(transaction),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"call\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"call\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    estimateGas(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                transaction: this._getTransactionRequest(transaction)\n            });\n            const result = yield this.perform(\"estimateGas\", params);\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"estimateGas\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    _getAddress(addressOrName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            addressOrName = yield addressOrName;\n            if (typeof (addressOrName) !== \"string\") {\n                logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n            }\n            const address = yield this.resolveName(addressOrName);\n            if (address == null) {\n                logger.throwError(\"ENS name not configured\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `resolveName(${JSON.stringify(addressOrName)})`\n                });\n            }\n            return address;\n        });\n    }\n    _getBlock(blockHashOrBlockTag, includeTransactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            blockHashOrBlockTag = yield blockHashOrBlockTag;\n            // If blockTag is a number (not \"latest\", etc), this is the block number\n            let blockNumber = -128;\n            const params = {\n                includeTransactions: !!includeTransactions\n            };\n            if (isHexString(blockHashOrBlockTag, 32)) {\n                params.blockHash = blockHashOrBlockTag;\n            }\n            else {\n                try {\n                    params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);\n                    if (isHexString(params.blockTag)) {\n                        blockNumber = parseInt(params.blockTag.substring(2), 16);\n                    }\n                }\n                catch (error) {\n                    logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n                }\n            }\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const block = yield this.perform(\"getBlock\", params);\n                // Block was not found\n                if (block == null) {\n                    // For blockhashes, if we didn't say it existed, that blockhash may\n                    // not exist. If we did see it though, perhaps from a log, we know\n                    // it exists, and this node is just not caught up yet.\n                    if (params.blockHash != null) {\n                        if (this._emitted[\"b:\" + params.blockHash] == null) {\n                            return null;\n                        }\n                    }\n                    // For block tags, if we are asking for a future block, we return null\n                    if (params.blockTag != null) {\n                        if (blockNumber > this._emitted.block) {\n                            return null;\n                        }\n                    }\n                    // Retry on the next block\n                    return undefined;\n                }\n                // Add transactions\n                if (includeTransactions) {\n                    let blockNumber = null;\n                    for (let i = 0; i < block.transactions.length; i++) {\n                        const tx = block.transactions[i];\n                        if (tx.blockNumber == null) {\n                            tx.confirmations = 0;\n                        }\n                        else if (tx.confirmations == null) {\n                            if (blockNumber == null) {\n                                blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                            }\n                            // Add the confirmations using the fast block number (pessimistic)\n                            let confirmations = (blockNumber - tx.blockNumber) + 1;\n                            if (confirmations <= 0) {\n                                confirmations = 1;\n                            }\n                            tx.confirmations = confirmations;\n                        }\n                    }\n                    const blockWithTxs = this.formatter.blockWithTransactions(block);\n                    blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));\n                    return blockWithTxs;\n                }\n                return this.formatter.block(block);\n            }), { oncePoll: this });\n        });\n    }\n    getBlock(blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, false));\n    }\n    getBlockWithTransactions(blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, true));\n    }\n    getTransaction(transactionHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const result = yield this.perform(\"getTransaction\", params);\n                if (result == null) {\n                    if (this._emitted[\"t:\" + transactionHash] == null) {\n                        return null;\n                    }\n                    return undefined;\n                }\n                const tx = this.formatter.transactionResponse(result);\n                if (tx.blockNumber == null) {\n                    tx.confirmations = 0;\n                }\n                else if (tx.confirmations == null) {\n                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = (blockNumber - tx.blockNumber) + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    tx.confirmations = confirmations;\n                }\n                return this._wrapTransaction(tx);\n            }), { oncePoll: this });\n        });\n    }\n    getTransactionReceipt(transactionHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const result = yield this.perform(\"getTransactionReceipt\", params);\n                if (result == null) {\n                    if (this._emitted[\"t:\" + transactionHash] == null) {\n                        return null;\n                    }\n                    return undefined;\n                }\n                // \"geth-etc\" returns receipts before they are ready\n                if (result.blockHash == null) {\n                    return undefined;\n                }\n                const receipt = this.formatter.receipt(result);\n                if (receipt.blockNumber == null) {\n                    receipt.confirmations = 0;\n                }\n                else if (receipt.confirmations == null) {\n                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = (blockNumber - receipt.blockNumber) + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    receipt.confirmations = confirmations;\n                }\n                return receipt;\n            }), { oncePoll: this });\n        });\n    }\n    getLogs(filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({ filter: this._getFilter(filter) });\n            const logs = yield this.perform(\"getLogs\", params);\n            logs.forEach((log) => {\n                if (log.removed == null) {\n                    log.removed = false;\n                }\n            });\n            return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n        });\n    }\n    getEtherPrice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            return this.perform(\"getEtherPrice\", {});\n        });\n    }\n    _getBlockTag(blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            blockTag = yield blockTag;\n            if (typeof (blockTag) === \"number\" && blockTag < 0) {\n                if (blockTag % 1) {\n                    logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n                }\n                let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                blockNumber += blockTag;\n                if (blockNumber < 0) {\n                    blockNumber = 0;\n                }\n                return this.formatter.blockTag(blockNumber);\n            }\n            return this.formatter.blockTag(blockTag);\n        });\n    }\n    getResolver(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const address = yield this._getResolver(name);\n                if (address == null) {\n                    return null;\n                }\n                return new Resolver(this, address, name);\n            }\n            catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                throw error;\n            }\n        });\n    }\n    _getResolver(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Get the resolver from the blockchain\n            const network = yield this.getNetwork();\n            // No ENS...\n            if (!network.ensAddress) {\n                logger.throwError(\"network does not support ENS\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"ENS\", network: network.name });\n            }\n            // keccak256(\"resolver(bytes32)\")\n            const transaction = {\n                to: network.ensAddress,\n                data: (\"0x0178b8bf\" + namehash(name).substring(2))\n            };\n            try {\n                return this.formatter.callAddress(yield this.call(transaction));\n            }\n            catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                throw error;\n            }\n        });\n    }\n    resolveName(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            name = yield name;\n            // If it is already an address, nothing to resolve\n            try {\n                return Promise.resolve(this.formatter.address(name));\n            }\n            catch (error) {\n                // If is is a hexstring, the address is bad (See #694)\n                if (isHexString(name)) {\n                    throw error;\n                }\n            }\n            if (typeof (name) !== \"string\") {\n                logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n            }\n            // Get the addr from the resovler\n            const resolver = yield this.getResolver(name);\n            if (!resolver) {\n                return null;\n            }\n            return yield resolver.getAddress();\n        });\n    }\n    lookupAddress(address) {\n        return __awaiter(this, void 0, void 0, function* () {\n            address = yield address;\n            address = this.formatter.address(address);\n            const reverseName = address.substring(2).toLowerCase() + \".addr.reverse\";\n            const resolverAddress = yield this._getResolver(reverseName);\n            if (!resolverAddress) {\n                return null;\n            }\n            // keccak(\"name(bytes32)\")\n            let bytes = arrayify(yield this.call({\n                to: resolverAddress,\n                data: (\"0x691f3431\" + namehash(reverseName).substring(2))\n            }));\n            // Strip off the dynamic string pointer (0x20)\n            if (bytes.length < 32 || !BigNumber.from(bytes.slice(0, 32)).eq(32)) {\n                return null;\n            }\n            bytes = bytes.slice(32);\n            // Not a length-prefixed string\n            if (bytes.length < 32) {\n                return null;\n            }\n            // Get the length of the string (from the length-prefix)\n            const length = BigNumber.from(bytes.slice(0, 32)).toNumber();\n            bytes = bytes.slice(32);\n            // Length longer than available data\n            if (length > bytes.length) {\n                return null;\n            }\n            const name = toUtf8String(bytes.slice(0, length));\n            // Make sure the reverse record matches the foward record\n            const addr = yield this.resolveName(name);\n            if (addr != address) {\n                return null;\n            }\n            return name;\n        });\n    }\n    getAvatar(nameOrAddress) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let resolver = null;\n            if (isHexString(nameOrAddress)) {\n                // Address; reverse lookup\n                const address = this.formatter.address(nameOrAddress);\n                const reverseName = address.substring(2).toLowerCase() + \".addr.reverse\";\n                const resolverAddress = yield this._getResolver(reverseName);\n                if (!resolverAddress) {\n                    return null;\n                }\n                resolver = new Resolver(this, resolverAddress, \"_\", address);\n            }\n            else {\n                // ENS name; forward lookup\n                resolver = yield this.getResolver(nameOrAddress);\n                if (!resolver) {\n                    return null;\n                }\n            }\n            const avatar = yield resolver.getAvatar();\n            if (avatar == null) {\n                return null;\n            }\n            return avatar.url;\n        });\n    }\n    perform(method, params) {\n        return logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    }\n    _startEvent(event) {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n    _stopEvent(event) {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n    _addEventListener(eventName, listener, once) {\n        const event = new Event(getEventTag(eventName), listener, once);\n        this._events.push(event);\n        this._startEvent(event);\n        return this;\n    }\n    on(eventName, listener) {\n        return this._addEventListener(eventName, listener, false);\n    }\n    once(eventName, listener) {\n        return this._addEventListener(eventName, listener, true);\n    }\n    emit(eventName, ...args) {\n        let result = false;\n        let stopped = [];\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag) {\n                return true;\n            }\n            setTimeout(() => {\n                event.listener.apply(this, args);\n            }, 0);\n            result = true;\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n            return true;\n        });\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return result;\n    }\n    listenerCount(eventName) {\n        if (!eventName) {\n            return this._events.length;\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event) => {\n            return (event.tag === eventTag);\n        }).length;\n    }\n    listeners(eventName) {\n        if (eventName == null) {\n            return this._events.map((event) => event.listener);\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events\n            .filter((event) => (event.tag === eventTag))\n            .map((event) => event.listener);\n    }\n    off(eventName, listener) {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n        const stopped = [];\n        let found = false;\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag || event.listener != listener) {\n                return true;\n            }\n            if (found) {\n                return true;\n            }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return this;\n    }\n    removeAllListeners(eventName) {\n        let stopped = [];\n        if (eventName == null) {\n            stopped = this._events;\n            this._events = [];\n        }\n        else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event) => {\n                if (event.tag !== eventTag) {\n                    return true;\n                }\n                stopped.push(event);\n                return false;\n            });\n        }\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return this;\n    }\n}\n","export const HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Signer } from \"@ethersproject/abstract-signer\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { checkProperties, deepCopy, defineReadOnly, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BaseProvider } from \"./base-provider\";\nconst errorGas = [\"call\", \"estimateGas\"];\nfunction checkError(method, error, params) {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n        if (e && e.message.match(\"reverted\") && isHexString(e.data)) {\n            return e.data;\n        }\n        logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n            error, data: \"0x\"\n        });\n    }\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof (error.error.message) === \"string\") {\n        message = error.error.message;\n    }\n    else if (typeof (error.body) === \"string\") {\n        message = error.body;\n    }\n    else if (typeof (error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n    const transaction = params.transaction || params.signedTransaction;\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n    // \"nonce too low\"\n    if (message.match(/nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced/)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            error, method, transaction\n        });\n    }\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n    throw error;\n}\nfunction timer(timeout) {\n    return new Promise(function (resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\nfunction getResult(payload) {\n    if (payload.error) {\n        // @TODO: not any\n        const error = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n    return payload.result;\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nconst _constructorGuard = {};\nexport class JsonRpcSigner extends Signer {\n    constructor(constructorGuard, provider, addressOrIndex) {\n        logger.checkNew(new.target, JsonRpcSigner);\n        super();\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n        defineReadOnly(this, \"provider\", provider);\n        if (addressOrIndex == null) {\n            addressOrIndex = 0;\n        }\n        if (typeof (addressOrIndex) === \"string\") {\n            defineReadOnly(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            defineReadOnly(this, \"_index\", null);\n        }\n        else if (typeof (addressOrIndex) === \"number\") {\n            defineReadOnly(this, \"_index\", addressOrIndex);\n            defineReadOnly(this, \"_address\", null);\n        }\n        else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n    connect(provider) {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n    connectUnchecked() {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n    getAddress() {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n        return this.provider.send(\"eth_accounts\", []).then((accounts) => {\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index]);\n        });\n    }\n    sendUncheckedTransaction(transaction) {\n        transaction = shallowCopy(transaction);\n        const fromAddress = this.getAddress().then((address) => {\n            if (address) {\n                address = address.toLowerCase();\n            }\n            return address;\n        });\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = shallowCopy(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter(this, void 0, void 0, function* () {\n                if (to == null) {\n                    return null;\n                }\n                const address = yield this.provider.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            }));\n        }\n        return resolveProperties({\n            tx: resolveProperties(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender }) => {\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            }\n            else {\n                tx.from = sender;\n            }\n            const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });\n            return this.provider.send(\"eth_sendTransaction\", [hexTx]).then((hash) => {\n                return hash;\n            }, (error) => {\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n    signTransaction(transaction) {\n        return logger.throwError(\"signing transactions is unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n    sendTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // This cannot be mined any earlier than any recent block\n            const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n            // Send the transaction\n            const hash = yield this.sendUncheckedTransaction(transaction);\n            try {\n                // Unfortunately, JSON-RPC only provides and opaque transaction hash\n                // for a response, and we need the actual transaction, so we poll\n                // for it; it should show up very quickly\n                return yield poll(() => __awaiter(this, void 0, void 0, function* () {\n                    const tx = yield this.provider.getTransaction(hash);\n                    if (tx === null) {\n                        return undefined;\n                    }\n                    return this.provider._wrapTransaction(tx, hash, blockNumber);\n                }), { oncePoll: this.provider });\n            }\n            catch (error) {\n                error.transactionHash = hash;\n                throw error;\n            }\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = ((typeof (message) === \"string\") ? toUtf8Bytes(message) : message);\n            const address = yield this.getAddress();\n            return yield this.provider.send(\"personal_sign\", [hexlify(data), address.toLowerCase()]);\n        });\n    }\n    _legacySignMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = ((typeof (message) === \"string\") ? toUtf8Bytes(message) : message);\n            const address = yield this.getAddress();\n            // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n            return yield this.provider.send(\"eth_sign\", [address.toLowerCase(), hexlify(data)]);\n        });\n    }\n    _signTypedData(domain, types, value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Populate any ENS names (in-place)\n            const populated = yield _TypedDataEncoder.resolveNames(domain, types, value, (name) => {\n                return this.provider.resolveName(name);\n            });\n            const address = yield this.getAddress();\n            return yield this.provider.send(\"eth_signTypedData_v4\", [\n                address.toLowerCase(),\n                JSON.stringify(_TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n            ]);\n        });\n    }\n    unlock(password) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const provider = this.provider;\n            const address = yield this.getAddress();\n            return provider.send(\"personal_unlockAccount\", [address.toLowerCase(), password, null]);\n        });\n    }\n}\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction) {\n        return this.sendUncheckedTransaction(transaction).then((hash) => {\n            return {\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations) => { return this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    }\n}\nconst allowedTransactionKeys = {\n    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n};\nexport class JsonRpcProvider extends BaseProvider {\n    constructor(url, network) {\n        logger.checkNew(new.target, JsonRpcProvider);\n        let networkOrReady = network;\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then((network) => {\n                        resolve(network);\n                    }, (error) => {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Default URL\n        if (!url) {\n            url = getStatic(this.constructor, \"defaultUrl\")();\n        }\n        if (typeof (url) === \"string\") {\n            defineReadOnly(this, \"connection\", Object.freeze({\n                url: url\n            }));\n        }\n        else {\n            defineReadOnly(this, \"connection\", Object.freeze(shallowCopy(url)));\n        }\n        this._nextId = 42;\n    }\n    get _cache() {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = {};\n        }\n        return this._eventLoopCache;\n    }\n    static defaultUrl() {\n        return \"http:/\\/localhost:8545\";\n    }\n    detectNetwork() {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(() => {\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n    _uncachedDetectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield timer(0);\n            let chainId = null;\n            try {\n                chainId = yield this.send(\"eth_chainId\", []);\n            }\n            catch (error) {\n                try {\n                    chainId = yield this.send(\"net_version\", []);\n                }\n                catch (error) { }\n            }\n            if (chainId != null) {\n                const getNetwork = getStatic(this.constructor, \"getNetwork\");\n                try {\n                    return getNetwork(BigNumber.from(chainId).toNumber());\n                }\n                catch (error) {\n                    return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                        chainId: chainId,\n                        event: \"invalidNetwork\",\n                        serverError: error\n                    });\n                }\n            }\n            return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                event: \"noNetwork\"\n            });\n        });\n    }\n    getSigner(addressOrIndex) {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n    getUncheckedSigner(addressOrIndex) {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n    listAccounts() {\n        return this.send(\"eth_accounts\", []).then((accounts) => {\n            return accounts.map((a) => this.formatter.address(a));\n        });\n    }\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: deepCopy(request),\n            provider: this\n        });\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = ([\"eth_chainId\", \"eth_blockNumber\"].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n            return result;\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n            throw error;\n        });\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(() => {\n                this._cache[method] = null;\n            }, 0);\n        }\n        return result;\n    }\n    prepareRequest(method, params) {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [\"eth_blockNumber\", []];\n            case \"getGasPrice\":\n                return [\"eth_gasPrice\", []];\n            case \"getBalance\":\n                return [\"eth_getBalance\", [getLowerCase(params.address), params.blockTag]];\n            case \"getTransactionCount\":\n                return [\"eth_getTransactionCount\", [getLowerCase(params.address), params.blockTag]];\n            case \"getCode\":\n                return [\"eth_getCode\", [getLowerCase(params.address), params.blockTag]];\n            case \"getStorageAt\":\n                return [\"eth_getStorageAt\", [getLowerCase(params.address), params.position, params.blockTag]];\n            case \"sendTransaction\":\n                return [\"eth_sendRawTransaction\", [params.signedTransaction]];\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [\"eth_getBlockByNumber\", [params.blockTag, !!params.includeTransactions]];\n                }\n                else if (params.blockHash) {\n                    return [\"eth_getBlockByHash\", [params.blockHash, !!params.includeTransactions]];\n                }\n                return null;\n            case \"getTransaction\":\n                return [\"eth_getTransactionByHash\", [params.transactionHash]];\n            case \"getTransactionReceipt\":\n                return [\"eth_getTransactionReceipt\", [params.transactionHash]];\n            case \"call\": {\n                const hexlifyTransaction = getStatic(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_call\", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];\n            }\n            case \"estimateGas\": {\n                const hexlifyTransaction = getStatic(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_estimateGas\", [hexlifyTransaction(params.transaction, { from: true })]];\n            }\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [\"eth_getLogs\", [params.filter]];\n            default:\n                break;\n        }\n        return null;\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Legacy networks do not like the type field being passed along (which\n            // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n            if (method === \"call\" || method === \"estimateGas\") {\n                const tx = params.transaction;\n                if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {\n                    // If there are no EIP-1559 properties, it might be non-EIP-a559\n                    if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                        const feeData = yield this.getFeeData();\n                        if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                            // Network doesn't know about EIP-1559 (and hence type)\n                            params = shallowCopy(params);\n                            params.transaction = shallowCopy(tx);\n                            delete params.transaction.type;\n                        }\n                    }\n                }\n            }\n            const args = this.prepareRequest(method, params);\n            if (args == null) {\n                logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n            }\n            try {\n                return yield this.send(args[0], args[1]);\n            }\n            catch (error) {\n                return checkError(method, error, params);\n            }\n        });\n    }\n    _startEvent(event) {\n        if (event.tag === \"pending\") {\n            this._startPending();\n        }\n        super._startEvent(event);\n    }\n    _startPending() {\n        if (this._pendingFilter != null) {\n            return;\n        }\n        const self = this;\n        const pendingFilter = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n        pendingFilter.then(function (filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [filterId]).then(function (hashes) {\n                    if (self._pendingFilter != pendingFilter) {\n                        return null;\n                    }\n                    let seq = Promise.resolve();\n                    hashes.forEach(function (hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function () {\n                            return self.getTransaction(hash).then(function (tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n                    return seq.then(function () {\n                        return timer(1000);\n                    });\n                }).then(function () {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [filterId]);\n                        return;\n                    }\n                    setTimeout(function () { poll(); }, 0);\n                    return null;\n                }).catch((error) => { });\n            }\n            poll();\n            return filterId;\n        }).catch((error) => { });\n    }\n    _stopEvent(event) {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction, allowExtra) {\n        // Check only allowed properties are given\n        const allowed = shallowCopy(allowedTransactionKeys);\n        if (allowExtra) {\n            for (const key in allowExtra) {\n                if (allowExtra[key]) {\n                    allowed[key] = true;\n                }\n            }\n        }\n        checkProperties(transaction, allowed);\n        const result = {};\n        // Some nodes (INFURA ropsten; INFURA mainnet is fine) do not like leading zeros.\n        [\"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            const value = hexValue(transaction[key]);\n            if (key === \"gasLimit\") {\n                key = \"gas\";\n            }\n            result[key] = value;\n        });\n        [\"from\", \"to\", \"data\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            result[key] = hexlify(transaction[key]);\n        });\n        if (transaction.accessList) {\n            result[\"accessList\"] = accessListify(transaction.accessList);\n        }\n        return result;\n    }\n}\n","\"use strict\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nlet WS = null;\ntry {\n    WS = WebSocket;\n    if (WS == null) {\n        throw new Error(\"inject please\");\n    }\n}\ncatch (error) {\n    const logger = new Logger(version);\n    WS = function () {\n        logger.throwError(\"WebSockets not supported in this environment\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    };\n}\n//export default WS;\n//module.exports = WS;\nexport { WS as WebSocket };\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nimport { WebSocket } from \"./ws\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\nlet NextId = 1;\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\nexport class WebSocketProvider extends JsonRpcProvider {\n    constructor(url, network) {\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n        super(url, network);\n        this._pollingInterval = -1;\n        this._wsReady = false;\n        defineReadOnly(this, \"_websocket\", new WebSocket(this.connection.url));\n        defineReadOnly(this, \"_requests\", {});\n        defineReadOnly(this, \"_subs\", {});\n        defineReadOnly(this, \"_subIds\", {});\n        defineReadOnly(this, \"_detectNetwork\", super.detectNetwork());\n        // Stall sending requests until the socket is open...\n        this._websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this._websocket.send(this._requests[id].payload);\n            });\n        };\n        this._websocket.onmessage = (messageEvent) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n                }\n                else {\n                    let error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        defineReadOnly(error, \"code\", result.error.code || null);\n                        defineReadOnly(error, \"response\", data);\n                    }\n                    else {\n                        error = new Error(\"unknown error\");\n                    }\n                    request.callback(error, undefined);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n                }\n            }\n            else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result);\n                }\n            }\n            else {\n                console.warn(\"this should not happen\");\n            }\n        };\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(() => {\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) {\n            fauxPoll.unref();\n        }\n    }\n    detectNetwork() {\n        return this._detectNetwork;\n    }\n    get pollingInterval() {\n        return 0;\n    }\n    resetEventsBlock(blockNumber) {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n    set pollingInterval(value) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return null;\n        });\n    }\n    set polling(value) {\n        if (!value) {\n            return;\n        }\n        logger.throwError(\"cannot set polling on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n    send(method, params) {\n        const rid = NextId++;\n        return new Promise((resolve, reject) => {\n            function callback(error, result) {\n                if (error) {\n                    return reject(error);\n                }\n                return resolve(result);\n            }\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n            this._requests[String(rid)] = { callback, payload };\n            if (this._wsReady) {\n                this._websocket.send(payload);\n            }\n        });\n    }\n    static defaultUrl() {\n        return \"ws:/\\/localhost:8546\";\n    }\n    _subscribe(tag, param, processFunc) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let subIdPromise = this._subIds[tag];\n            if (subIdPromise == null) {\n                subIdPromise = Promise.all(param).then((param) => {\n                    return this.send(\"eth_subscribe\", param);\n                });\n                this._subIds[tag] = subIdPromise;\n            }\n            const subId = yield subIdPromise;\n            this._subs[subId] = { tag, processFunc };\n        });\n    }\n    _startEvent(event) {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [\"newHeads\"], (result) => {\n                    const blockNumber = BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n            case \"pending\":\n                this._subscribe(\"pending\", [\"newPendingTransactions\"], (result) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n            case \"filter\":\n                this._subscribe(event.tag, [\"logs\", this._getFilter(event.filter)], (result) => {\n                    if (result.removed == null) {\n                        result.removed = false;\n                    }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n            case \"tx\": {\n                const emitReceipt = (event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) {\n                            return;\n                        }\n                        this.emit(hash, receipt);\n                    });\n                };\n                // In case it is already mined\n                emitReceipt(event);\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [\"newHeads\"], (result) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n    _stopEvent(event) {\n        let tag = event.tag;\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        }\n        else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n        const subId = this._subIds[tag];\n        if (!subId) {\n            return;\n        }\n        delete this._subIds[tag];\n        subId.then((subId) => {\n            if (!this._subs[subId]) {\n                return;\n            }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [subId]);\n        });\n    }\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Wait until we have connected before trying to disconnect\n            if (this._websocket.readyState === WebSocket.CONNECTING) {\n                yield (new Promise((resolve) => {\n                    this._websocket.onopen = function () {\n                        resolve(true);\n                    };\n                    this._websocket.onerror = function () {\n                        resolve(false);\n                    };\n                }));\n            }\n            // Hangup\n            // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n            this._websocket.close(1000);\n        });\n    }\n}\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { defineReadOnly, getStatic } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nexport class StaticJsonRpcProvider extends JsonRpcProvider {\n    detectNetwork() {\n        const _super = Object.create(null, {\n            detectNetwork: { get: () => super.detectNetwork }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            let network = this.network;\n            if (network == null) {\n                network = yield _super.detectNetwork.call(this);\n                if (!network) {\n                    logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // If still not set, set it\n                if (this._network == null) {\n                    // A static network does not support \"any\"\n                    defineReadOnly(this, \"_network\", network);\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return network;\n        });\n    }\n}\nexport class UrlJsonRpcProvider extends StaticJsonRpcProvider {\n    constructor(network, apiKey) {\n        logger.checkAbstract(new.target, UrlJsonRpcProvider);\n        // Normalize the Network and API Key\n        network = getStatic(new.target, \"getNetwork\")(network);\n        apiKey = getStatic(new.target, \"getApiKey\")(apiKey);\n        const connection = getStatic(new.target, \"getUrl\")(network, apiKey);\n        super(connection, network);\n        if (typeof (apiKey) === \"string\") {\n            defineReadOnly(this, \"apiKey\", apiKey);\n        }\n        else if (apiKey != null) {\n            Object.keys(apiKey).forEach((key) => {\n                defineReadOnly(this, key, apiKey[key]);\n            });\n        }\n    }\n    _startPending() {\n        logger.warn(\"WARNING: API provider does not support pending filters\");\n    }\n    isCommunityResource() {\n        return false;\n    }\n    getSigner(address) {\n        return logger.throwError(\"API provider does not support signing\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"getSigner\" });\n    }\n    listAccounts() {\n        return Promise.resolve([]);\n    }\n    // Return a defaultApiKey if null, otherwise validate the API key\n    static getApiKey(apiKey) {\n        return apiKey;\n    }\n    // Returns the url or connection for the given network and API key. The\n    // API key will have been sanitized by the getApiKey first, so any validation\n    // or transformations can be done there.\n    static getUrl(network, apiKey) {\n        return logger.throwError(\"not implemented; sub-classes must override getUrl\", Logger.errors.NOT_IMPLEMENTED, {\n            operation: \"getUrl\"\n        });\n    }\n}\n","\"use strict\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { showThrottleMessage } from \"./formatter\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n// This key was provided to ethers.js by Alchemy to be used by the\n// default provider, but it is recommended that for your own\n// production environments, that you acquire your own API key at:\n//   https://dashboard.alchemyapi.io\nconst defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\";\nexport class AlchemyWebSocketProvider extends WebSocketProvider {\n    constructor(network, apiKey) {\n        const provider = new AlchemyProvider(network, apiKey);\n        const url = provider.connection.url.replace(/^http/i, \"ws\")\n            .replace(\".alchemyapi.\", \".ws.alchemyapi.\");\n        super(url, provider.network);\n        defineReadOnly(this, \"apiKey\", provider.apiKey);\n    }\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n}\nexport class AlchemyProvider extends UrlJsonRpcProvider {\n    static getWebSocketProvider(network, apiKey) {\n        return new AlchemyWebSocketProvider(network, apiKey);\n    }\n    static getApiKey(apiKey) {\n        if (apiKey == null) {\n            return defaultApiKey;\n        }\n        if (apiKey && typeof (apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"eth-mainnet.alchemyapi.io/v2/\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.alchemyapi.io/v2/\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.alchemyapi.io/v2/\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.alchemyapi.io/v2/\";\n                break;\n            case \"kovan\":\n                host = \"eth-kovan.alchemyapi.io/v2/\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum\":\n                host = \"arb-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arb-rinkeby.g.alchemy.com/v2/\";\n                break;\n            case \"optimism\":\n                host = \"opt-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"optimism-kovan\":\n                host = \"opt-kovan.g.alchemy.com/v2/\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + apiKey),\n            throttleCallback: (attempt, url) => {\n                if (apiKey === defaultApiKey) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n    }\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport class CloudflareProvider extends UrlJsonRpcProvider {\n    static getApiKey(apiKey) {\n        if (apiKey != null) {\n            logger.throwArgumentError(\"apiKey not supported for cloudflare\", \"apiKey\", apiKey);\n        }\n        return null;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://cloudflare-eth.com/\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return host;\n    }\n    perform(method, params) {\n        const _super = Object.create(null, {\n            perform: { get: () => super.perform }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            // The Cloudflare provider does not support eth_blockNumber,\n            // so we get the latest block and pull it from that\n            if (method === \"getBlockNumber\") {\n                const block = yield _super.perform.call(this, \"getBlock\", { blockTag: \"latest\" });\n                return block.number;\n            }\n            return _super.perform.call(this, method, params);\n        });\n    }\n}\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { fetchJson } from \"@ethersproject/web\";\nimport { showThrottleMessage } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BaseProvider } from \"./base-provider\";\n// The transaction has already been sanitized by the calls in Provider\nfunction getTransactionPostData(transaction) {\n    const result = {};\n    for (let key in transaction) {\n        if (transaction[key] == null) {\n            continue;\n        }\n        let value = transaction[key];\n        if (key === \"type\" && value === 0) {\n            continue;\n        }\n        // Quantity-types require no leading zero, unless 0\n        if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {\n            value = hexValue(hexlify(value));\n        }\n        else if (key === \"accessList\") {\n            value = \"[\" + accessListify(value).map((set) => {\n                return `{address:\"${set.address}\",storageKeys:[\"${set.storageKeys.join('\",\"')}\"]}`;\n            }).join(\",\") + \"]\";\n        }\n        else {\n            value = hexlify(value);\n        }\n        result[key] = value;\n    }\n    return result;\n}\nfunction getResult(result) {\n    // getLogs, getHistory have weird success responses\n    if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n        return result.result;\n    }\n    if (result.status != 1 || result.message != \"OK\") {\n        const error = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        if ((result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n            error.throttleRetry = true;\n        }\n        throw error;\n    }\n    return result.result;\n}\nfunction getJsonResult(result) {\n    // This response indicates we are being throttled\n    if (result && result.status == 0 && result.message == \"NOTOK\" && (result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n        const error = new Error(\"throttled response\");\n        error.result = JSON.stringify(result);\n        error.throttleRetry = true;\n        throw error;\n    }\n    if (result.jsonrpc != \"2.0\") {\n        // @TODO: not any\n        const error = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        throw error;\n    }\n    if (result.error) {\n        // @TODO: not any\n        const error = new Error(result.error.message || \"unknown error\");\n        if (result.error.code) {\n            error.code = result.error.code;\n        }\n        if (result.error.data) {\n            error.data = result.error.data;\n        }\n        throw error;\n    }\n    return result.result;\n}\n// The blockTag was normalized as a string by the Provider pre-perform operations\nfunction checkLogTag(blockTag) {\n    if (blockTag === \"pending\") {\n        throw new Error(\"pending not supported\");\n    }\n    if (blockTag === \"latest\") {\n        return blockTag;\n    }\n    return parseInt(blockTag.substring(2), 16);\n}\nconst defaultApiKey = \"9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB\";\nfunction checkError(method, error, transaction) {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n        // Etherscan keeps changing their string\n        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {\n            // Etherscan prefixes the data like \"Reverted 0x1234\"\n            let data = e.data;\n            if (data) {\n                data = \"0x\" + data.replace(/^.*0x/i, \"\");\n            }\n            if (isHexString(data)) {\n                return data;\n            }\n            logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n                error, data: \"0x\"\n            });\n        }\n    }\n    // Get the message from any nested error structure\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR) {\n        if (error.error && typeof (error.error.message) === \"string\") {\n            message = error.error.message;\n        }\n        else if (typeof (error.body) === \"string\") {\n            message = error.body;\n        }\n        else if (typeof (error.responseText) === \"string\") {\n            message = error.responseText;\n        }\n    }\n    message = (message || \"\").toLowerCase();\n    // \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\n    if (message.match(/insufficient funds/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n    // \"Transaction with the same hash was already imported.\"\n    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n    // \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\n    if (message.match(/another transaction with same nonce/)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n    if (message.match(/execution failed due to an exception|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n    throw error;\n}\nexport class EtherscanProvider extends BaseProvider {\n    constructor(network, apiKey) {\n        logger.checkNew(new.target, EtherscanProvider);\n        super(network);\n        defineReadOnly(this, \"baseUrl\", this.getBaseUrl());\n        defineReadOnly(this, \"apiKey\", apiKey || defaultApiKey);\n    }\n    getBaseUrl() {\n        switch (this.network ? this.network.name : \"invalid\") {\n            case \"homestead\":\n                return \"https:/\\/api.etherscan.io\";\n            case \"ropsten\":\n                return \"https:/\\/api-ropsten.etherscan.io\";\n            case \"rinkeby\":\n                return \"https:/\\/api-rinkeby.etherscan.io\";\n            case \"kovan\":\n                return \"https:/\\/api-kovan.etherscan.io\";\n            case \"goerli\":\n                return \"https:/\\/api-goerli.etherscan.io\";\n            default:\n        }\n        return logger.throwArgumentError(\"unsupported network\", \"network\", name);\n    }\n    getUrl(module, params) {\n        const query = Object.keys(params).reduce((accum, key) => {\n            const value = params[key];\n            if (value != null) {\n                accum += `&${key}=${value}`;\n            }\n            return accum;\n        }, \"\");\n        const apiKey = ((this.apiKey) ? `&apikey=${this.apiKey}` : \"\");\n        return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;\n    }\n    getPostUrl() {\n        return `${this.baseUrl}/api`;\n    }\n    getPostData(module, params) {\n        params.module = module;\n        params.apikey = this.apiKey;\n        return params;\n    }\n    fetch(module, params, post) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = (post ? this.getPostUrl() : this.getUrl(module, params));\n            const payload = (post ? this.getPostData(module, params) : null);\n            const procFunc = (module === \"proxy\") ? getJsonResult : getResult;\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: url,\n                provider: this\n            });\n            const connection = {\n                url: url,\n                throttleSlotInterval: 1000,\n                throttleCallback: (attempt, url) => {\n                    if (this.isCommunityResource()) {\n                        showThrottleMessage();\n                    }\n                    return Promise.resolve(true);\n                }\n            };\n            let payloadStr = null;\n            if (payload) {\n                connection.headers = { \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\" };\n                payloadStr = Object.keys(payload).map((key) => {\n                    return `${key}=${payload[key]}`;\n                }).join(\"&\");\n            }\n            const result = yield fetchJson(connection, payloadStr, procFunc || getJsonResult);\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: url,\n                response: deepCopy(result),\n                provider: this\n            });\n            return result;\n        });\n    }\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.network;\n        });\n    }\n    perform(method, params) {\n        const _super = Object.create(null, {\n            perform: { get: () => super.perform }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            switch (method) {\n                case \"getBlockNumber\":\n                    return this.fetch(\"proxy\", { action: \"eth_blockNumber\" });\n                case \"getGasPrice\":\n                    return this.fetch(\"proxy\", { action: \"eth_gasPrice\" });\n                case \"getBalance\":\n                    // Returns base-10 result\n                    return this.fetch(\"account\", {\n                        action: \"balance\",\n                        address: params.address,\n                        tag: params.blockTag\n                    });\n                case \"getTransactionCount\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getTransactionCount\",\n                        address: params.address,\n                        tag: params.blockTag\n                    });\n                case \"getCode\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getCode\",\n                        address: params.address,\n                        tag: params.blockTag\n                    });\n                case \"getStorageAt\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getStorageAt\",\n                        address: params.address,\n                        position: params.position,\n                        tag: params.blockTag\n                    });\n                case \"sendTransaction\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_sendRawTransaction\",\n                        hex: params.signedTransaction\n                    }, true).catch((error) => {\n                        return checkError(\"sendTransaction\", error, params.signedTransaction);\n                    });\n                case \"getBlock\":\n                    if (params.blockTag) {\n                        return this.fetch(\"proxy\", {\n                            action: \"eth_getBlockByNumber\",\n                            tag: params.blockTag,\n                            boolean: (params.includeTransactions ? \"true\" : \"false\")\n                        });\n                    }\n                    throw new Error(\"getBlock by blockHash not implemented\");\n                case \"getTransaction\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getTransactionByHash\",\n                        txhash: params.transactionHash\n                    });\n                case \"getTransactionReceipt\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getTransactionReceipt\",\n                        txhash: params.transactionHash\n                    });\n                case \"call\": {\n                    if (params.blockTag !== \"latest\") {\n                        throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                    }\n                    const postData = getTransactionPostData(params.transaction);\n                    postData.module = \"proxy\";\n                    postData.action = \"eth_call\";\n                    try {\n                        return yield this.fetch(\"proxy\", postData, true);\n                    }\n                    catch (error) {\n                        return checkError(\"call\", error, params.transaction);\n                    }\n                }\n                case \"estimateGas\": {\n                    const postData = getTransactionPostData(params.transaction);\n                    postData.module = \"proxy\";\n                    postData.action = \"eth_estimateGas\";\n                    try {\n                        return yield this.fetch(\"proxy\", postData, true);\n                    }\n                    catch (error) {\n                        return checkError(\"estimateGas\", error, params.transaction);\n                    }\n                }\n                case \"getLogs\": {\n                    const args = { action: \"getLogs\" };\n                    if (params.filter.fromBlock) {\n                        args.fromBlock = checkLogTag(params.filter.fromBlock);\n                    }\n                    if (params.filter.toBlock) {\n                        args.toBlock = checkLogTag(params.filter.toBlock);\n                    }\n                    if (params.filter.address) {\n                        args.address = params.filter.address;\n                    }\n                    // @TODO: We can handle slightly more complicated logs using the logs API\n                    if (params.filter.topics && params.filter.topics.length > 0) {\n                        if (params.filter.topics.length > 1) {\n                            logger.throwError(\"unsupported topic count\", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                        }\n                        if (params.filter.topics.length === 1) {\n                            const topic0 = params.filter.topics[0];\n                            if (typeof (topic0) !== \"string\" || topic0.length !== 66) {\n                                logger.throwError(\"unsupported topic format\", Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                            }\n                            args.topic0 = topic0;\n                        }\n                    }\n                    const logs = yield this.fetch(\"logs\", args);\n                    // Cache txHash => blockHash\n                    let blocks = {};\n                    // Add any missing blockHash to the logs\n                    for (let i = 0; i < logs.length; i++) {\n                        const log = logs[i];\n                        if (log.blockHash != null) {\n                            continue;\n                        }\n                        if (blocks[log.blockNumber] == null) {\n                            const block = yield this.getBlock(log.blockNumber);\n                            if (block) {\n                                blocks[log.blockNumber] = block.hash;\n                            }\n                        }\n                        log.blockHash = blocks[log.blockNumber];\n                    }\n                    return logs;\n                }\n                case \"getEtherPrice\":\n                    if (this.network.name !== \"homestead\") {\n                        return 0.0;\n                    }\n                    return parseFloat((yield this.fetch(\"stats\", { action: \"ethprice\" })).ethusd);\n                default:\n                    break;\n            }\n            return _super.perform.call(this, method, params);\n        });\n    }\n    // Note: The `page` page parameter only allows pagination within the\n    //       10,000 window available without a page and offset parameter\n    //       Error: Result window is too large, PageNo x Offset size must\n    //              be less than or equal to 10000\n    getHistory(addressOrName, startBlock, endBlock) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const params = {\n                action: \"txlist\",\n                address: (yield this.resolveName(addressOrName)),\n                startblock: ((startBlock == null) ? 0 : startBlock),\n                endblock: ((endBlock == null) ? 99999999 : endBlock),\n                sort: \"asc\"\n            };\n            const result = yield this.fetch(\"account\", params);\n            return result.map((tx) => {\n                [\"contractAddress\", \"to\"].forEach(function (key) {\n                    if (tx[key] == \"\") {\n                        delete tx[key];\n                    }\n                });\n                if (tx.creates == null && tx.contractAddress != null) {\n                    tx.creates = tx.contractAddress;\n                }\n                const item = this.formatter.transactionResponse(tx);\n                if (tx.timeStamp) {\n                    item.timestamp = parseInt(tx.timeStamp);\n                }\n                return item;\n            });\n        });\n    }\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n","\"use strict\";\nexport function shuffled(array) {\n    array = array.slice();\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        const tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n    return array;\n}\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nfunction now() { return (new Date()).getTime(); }\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks) {\n    let result = null;\n    for (let i = 0; i < networks.length; i++) {\n        const network = networks[i];\n        // Null! We do not know our network; bail.\n        if (network == null) {\n            return null;\n        }\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId &&\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n            }\n        }\n        else {\n            result = network;\n        }\n    }\n    return result;\n}\nfunction median(values, maxDelta) {\n    values = values.slice().sort();\n    const middle = Math.floor(values.length / 2);\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n    // Even length; take the average of the two middle\n    const a = values[middle - 1], b = values[middle];\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n        return null;\n    }\n    return (a + b) / 2;\n}\nfunction serialize(value) {\n    if (value === null) {\n        return \"null\";\n    }\n    else if (typeof (value) === \"number\" || typeof (value) === \"boolean\") {\n        return JSON.stringify(value);\n    }\n    else if (typeof (value) === \"string\") {\n        return value;\n    }\n    else if (BigNumber.isBigNumber(value)) {\n        return value.toString();\n    }\n    else if (Array.isArray(value)) {\n        return JSON.stringify(value.map((i) => serialize(i)));\n    }\n    else if (typeof (value) === \"object\") {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map((key) => {\n            let v = value[key];\n            if (typeof (v) === \"function\") {\n                v = \"[function]\";\n            }\n            else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n    throw new Error(\"unknown value type: \" + typeof (value));\n}\n// Next request ID to use for emitting debug info\nlet nextRid = 1;\n;\nfunction stall(duration) {\n    let cancel = null;\n    let timer = null;\n    let promise = (new Promise((resolve) => {\n        cancel = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve();\n        };\n        timer = setTimeout(cancel, duration);\n    }));\n    const wait = (func) => {\n        promise = promise.then(func);\n        return promise;\n    };\n    function getPromise() {\n        return promise;\n    }\n    return { cancel, getPromise, wait };\n}\nconst ForwardErrors = [\n    Logger.errors.CALL_EXCEPTION,\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n    Logger.errors.UNPREDICTABLE_GAS_LIMIT\n];\nconst ForwardProperties = [\n    \"address\",\n    \"args\",\n    \"errorArgs\",\n    \"errorSignature\",\n    \"method\",\n    \"transaction\",\n];\n;\nfunction exposeDebugConfig(config, now) {\n    const result = {\n        weight: config.weight\n    };\n    Object.defineProperty(result, \"provider\", { get: () => config.provider });\n    if (config.start) {\n        result.start = config.start;\n    }\n    if (now) {\n        result.duration = (now - config.start);\n    }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        }\n        else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\nfunction normalizedTally(normalize, quorum) {\n    return function (configs) {\n        // Count the votes for each result\n        const tally = {};\n        configs.forEach((c) => {\n            const value = normalize(c.result);\n            if (!tally[value]) {\n                tally[value] = { count: 0, result: c.result };\n            }\n            tally[value].count++;\n        });\n        // Check for a quorum on any given result\n        const keys = Object.keys(tally);\n        for (let i = 0; i < keys.length; i++) {\n            const check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n        // No quroum\n        return undefined;\n    };\n}\nfunction getProcessFunc(provider, method, params) {\n    let normalize = serialize;\n    switch (method) {\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function (configs) {\n                const values = configs.map((c) => c.result);\n                // Get the median block number\n                let blockNumber = median(configs.map((c) => c.result), 2);\n                if (blockNumber == null) {\n                    return undefined;\n                }\n                blockNumber = Math.ceil(blockNumber);\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) {\n                    blockNumber++;\n                }\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n                return provider._highestBlockNumber;\n            };\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function (configs) {\n                const values = configs.map((c) => c.result);\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            };\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function (configs) {\n                return median(configs.map((c) => c.result));\n            };\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function (tx) {\n                if (tx == null) {\n                    return null;\n                }\n                tx = shallowCopy(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            };\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    block = shallowCopy(block);\n                    block.transactions = block.transactions.map((tx) => {\n                        tx = shallowCopy(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            }\n            else {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    return serialize(block);\n                };\n            }\n            break;\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n}\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nfunction waitForSync(config, blockNumber) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const provider = (config.provider);\n        if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n            return provider;\n        }\n        return poll(() => {\n            return new Promise((resolve, reject) => {\n                setTimeout(function () {\n                    // We are synced\n                    if (provider.blockNumber >= blockNumber) {\n                        return resolve(provider);\n                    }\n                    // We're done; just quit\n                    if (config.cancelled) {\n                        return resolve(null);\n                    }\n                    // Try again, next block\n                    return resolve(undefined);\n                }, 0);\n            });\n        }, { oncePoll: provider });\n    });\n}\nfunction getRunner(config, currentBlockNumber, method, params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let provider = config.provider;\n        switch (method) {\n            case \"getBlockNumber\":\n            case \"getGasPrice\":\n                return provider[method]();\n            case \"getEtherPrice\":\n                if (provider.getEtherPrice) {\n                    return provider.getEtherPrice();\n                }\n                break;\n            case \"getBalance\":\n            case \"getTransactionCount\":\n            case \"getCode\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[method](params.address, params.blockTag || \"latest\");\n            case \"getStorageAt\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n            case \"getBlock\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[(params.includeTransactions ? \"getBlockWithTransactions\" : \"getBlock\")](params.blockTag || params.blockHash);\n            case \"call\":\n            case \"estimateGas\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[method](params.transaction);\n            case \"getTransaction\":\n            case \"getTransactionReceipt\":\n                return provider[method](params.transactionHash);\n            case \"getLogs\": {\n                let filter = params.filter;\n                if ((filter.fromBlock && isHexString(filter.fromBlock)) || (filter.toBlock && isHexString(filter.toBlock))) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider.getLogs(filter);\n            }\n        }\n        return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n            method: method,\n            params: params\n        });\n    });\n}\nexport class FallbackProvider extends BaseProvider {\n    constructor(providers, quorum) {\n        logger.checkNew(new.target, FallbackProvider);\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n        const providerConfigs = providers.map((configOrProvider, index) => {\n            if (Provider.isProvider(configOrProvider)) {\n                const stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n                const priority = 1;\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });\n            }\n            const config = shallowCopy(configOrProvider);\n            if (config.priority == null) {\n                config.priority = 1;\n            }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n            }\n            if (config.weight == null) {\n                config.weight = 1;\n            }\n            const weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${index}].weight`, weight);\n            }\n            return Object.freeze(config);\n        });\n        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);\n        if (quorum == null) {\n            quorum = total / 2;\n        }\n        else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n        // Are all providers' networks are known\n        let networkOrReady = checkNetworks(providerConfigs.map((c) => (c.provider).network));\n        // Not all networks are known; we must stall\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then(resolve, reject);\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Preserve a copy, so we do not get mutated\n        defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n        defineReadOnly(this, \"quorum\", quorum);\n        this._highestBlockNumber = -1;\n    }\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const networks = yield Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));\n            return checkNetworks(networks);\n        });\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Sending transactions is special; always broadcast it to all backends\n            if (method === \"sendTransaction\") {\n                const results = yield Promise.all(this.providerConfigs.map((c) => {\n                    return c.provider.sendTransaction(params.signedTransaction).then((result) => {\n                        return result.hash;\n                    }, (error) => {\n                        return error;\n                    });\n                }));\n                // Any success is good enough (other errors are likely \"already seen\" errors\n                for (let i = 0; i < results.length; i++) {\n                    const result = results[i];\n                    if (typeof (result) === \"string\") {\n                        return result;\n                    }\n                }\n                // They were all an error; pick the first error\n                throw results[0];\n            }\n            // We need to make sure we are in sync with our backends, so we need\n            // to know this before we can make a lot of calls\n            if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n                yield this.getBlockNumber();\n            }\n            const processFunc = getProcessFunc(this, method, params);\n            // Shuffle the providers and then sort them by their priority; we\n            // shallowCopy them since we will store the result in them too\n            const configs = shuffled(this.providerConfigs.map(shallowCopy));\n            configs.sort((a, b) => (a.priority - b.priority));\n            const currentBlockNumber = this._highestBlockNumber;\n            let i = 0;\n            let first = true;\n            while (true) {\n                const t0 = now();\n                // Compute the inflight weight (exclude anything past)\n                let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))\n                    .reduce((accum, c) => (accum + c.weight), 0);\n                // Start running enough to meet quorum\n                while (inflightWeight < this.quorum && i < configs.length) {\n                    const config = configs[i++];\n                    const rid = nextRid++;\n                    config.start = now();\n                    config.staller = stall(config.stallTimeout);\n                    config.staller.wait(() => { config.staller = null; });\n                    config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {\n                        config.done = true;\n                        config.result = result;\n                        if (this.listenerCount(\"debug\")) {\n                            this.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, now()),\n                                request: { method: method, params: deepCopy(params) },\n                                provider: this\n                            });\n                        }\n                    }, (error) => {\n                        config.done = true;\n                        config.error = error;\n                        if (this.listenerCount(\"debug\")) {\n                            this.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, now()),\n                                request: { method: method, params: deepCopy(params) },\n                                provider: this\n                            });\n                        }\n                    });\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, null),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                    }\n                    inflightWeight += config.weight;\n                }\n                // Wait for anything meaningful to finish or stall out\n                const waiting = [];\n                configs.forEach((c) => {\n                    if (c.done || !c.runner) {\n                        return;\n                    }\n                    waiting.push(c.runner);\n                    if (c.staller) {\n                        waiting.push(c.staller.getPromise());\n                    }\n                });\n                if (waiting.length) {\n                    yield Promise.race(waiting);\n                }\n                // Check the quorum and process the results; the process function\n                // may additionally decide the quorum is not met\n                const results = configs.filter((c) => (c.done && c.error == null));\n                if (results.length >= this.quorum) {\n                    const result = processFunc(results);\n                    if (result !== undefined) {\n                        // Shut down any stallers\n                        configs.forEach(c => {\n                            if (c.staller) {\n                                c.staller.cancel();\n                            }\n                            c.cancelled = true;\n                        });\n                        return result;\n                    }\n                    if (!first) {\n                        yield stall(100).getPromise();\n                    }\n                    first = false;\n                }\n                // No result, check for errors that should be forwarded\n                const errors = configs.reduce((accum, c) => {\n                    if (!c.done || c.error == null) {\n                        return accum;\n                    }\n                    const code = (c.error).code;\n                    if (ForwardErrors.indexOf(code) >= 0) {\n                        if (!accum[code]) {\n                            accum[code] = { error: c.error, weight: 0 };\n                        }\n                        accum[code].weight += c.weight;\n                    }\n                    return accum;\n                }, ({}));\n                Object.keys(errors).forEach((errorCode) => {\n                    const tally = errors[errorCode];\n                    if (tally.weight < this.quorum) {\n                        return;\n                    }\n                    // Shut down any stallers\n                    configs.forEach(c => {\n                        if (c.staller) {\n                            c.staller.cancel();\n                        }\n                        c.cancelled = true;\n                    });\n                    const e = (tally.error);\n                    const props = {};\n                    ForwardProperties.forEach((name) => {\n                        if (e[name] == null) {\n                            return;\n                        }\n                        props[name] = e[name];\n                    });\n                    logger.throwError(e.reason || e.message, errorCode, props);\n                });\n                // All configs have run to completion; we will never get more data\n                if (configs.filter((c) => !c.done).length === 0) {\n                    break;\n                }\n            }\n            // Shut down any stallers; shouldn't be any\n            configs.forEach(c => {\n                if (c.staller) {\n                    c.staller.cancel();\n                }\n                c.cancelled = true;\n            });\n            return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n                method: method,\n                params: params,\n                //results: configs.map((c) => c.result),\n                //errors: configs.map((c) => c.error),\n                results: configs.map((c) => exposeDebugConfig(c)),\n                provider: this\n            });\n        });\n    }\n}\n","\"use strict\";\nconst IpcProvider = null;\nexport { IpcProvider };\n","\"use strict\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { showThrottleMessage } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nconst defaultProjectId = \"84842078b09946638c03157f83405213\";\nexport class InfuraWebSocketProvider extends WebSocketProvider {\n    constructor(network, apiKey) {\n        const provider = new InfuraProvider(network, apiKey);\n        const connection = provider.connection;\n        if (connection.password) {\n            logger.throwError(\"INFURA WebSocket project secrets unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"InfuraProvider.getWebSocketProvider()\"\n            });\n        }\n        const url = connection.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n        super(url, network);\n        defineReadOnly(this, \"apiKey\", provider.projectId);\n        defineReadOnly(this, \"projectId\", provider.projectId);\n        defineReadOnly(this, \"projectSecret\", provider.projectSecret);\n    }\n    isCommunityResource() {\n        return (this.projectId === defaultProjectId);\n    }\n}\nexport class InfuraProvider extends UrlJsonRpcProvider {\n    static getWebSocketProvider(network, apiKey) {\n        return new InfuraWebSocketProvider(network, apiKey);\n    }\n    static getApiKey(apiKey) {\n        const apiKeyObj = {\n            apiKey: defaultProjectId,\n            projectId: defaultProjectId,\n            projectSecret: null\n        };\n        if (apiKey == null) {\n            return apiKeyObj;\n        }\n        if (typeof (apiKey) === \"string\") {\n            apiKeyObj.projectId = apiKey;\n        }\n        else if (apiKey.projectSecret != null) {\n            logger.assertArgument((typeof (apiKey.projectId) === \"string\"), \"projectSecret requires a projectId\", \"projectId\", apiKey.projectId);\n            logger.assertArgument((typeof (apiKey.projectSecret) === \"string\"), \"invalid projectSecret\", \"projectSecret\", \"[REDACTED]\");\n            apiKeyObj.projectId = apiKey.projectId;\n            apiKeyObj.projectSecret = apiKey.projectSecret;\n        }\n        else if (apiKey.projectId) {\n            apiKeyObj.projectId = apiKey.projectId;\n        }\n        apiKeyObj.apiKey = apiKeyObj.projectId;\n        return apiKeyObj;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"homestead\":\n                host = \"mainnet.infura.io\";\n                break;\n            case \"ropsten\":\n                host = \"ropsten.infura.io\";\n                break;\n            case \"rinkeby\":\n                host = \"rinkeby.infura.io\";\n                break;\n            case \"kovan\":\n                host = \"kovan.infura.io\";\n                break;\n            case \"goerli\":\n                host = \"goerli.infura.io\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.infura.io\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.infura.io\";\n                break;\n            case \"optimism\":\n                host = \"optimism-mainnet.infura.io\";\n                break;\n            case \"optimism-kovan\":\n                host = \"optimism-kovan.infura.io\";\n                break;\n            case \"arbitrum\":\n                host = \"arbitrum-mainnet.infura.io\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arbitrum-rinkeby.infura.io\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n        const connection = {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + \"/v3/\" + apiKey.projectId),\n            throttleCallback: (attempt, url) => {\n                if (apiKey.projectId === defaultProjectId) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret;\n        }\n        return connection;\n    }\n    isCommunityResource() {\n        return (this.projectId === defaultProjectId);\n    }\n}\n","import { deepCopy } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n// Experimental\nexport class JsonRpcBatchProvider extends JsonRpcProvider {\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        if (this._pendingBatch == null) {\n            this._pendingBatch = [];\n        }\n        const inflightRequest = { request, resolve: null, reject: null };\n        const promise = new Promise((resolve, reject) => {\n            inflightRequest.resolve = resolve;\n            inflightRequest.reject = reject;\n        });\n        this._pendingBatch.push(inflightRequest);\n        if (!this._pendingBatchAggregator) {\n            // Schedule batch for next event loop + short duration\n            this._pendingBatchAggregator = setTimeout(() => {\n                // Get teh current batch and clear it, so new requests\n                // go into the next batch\n                const batch = this._pendingBatch;\n                this._pendingBatch = null;\n                this._pendingBatchAggregator = null;\n                // Get the request as an array of requests\n                const request = batch.map((inflight) => inflight.request);\n                this.emit(\"debug\", {\n                    action: \"requestBatch\",\n                    request: deepCopy(request),\n                    provider: this\n                });\n                return fetchJson(this.connection, JSON.stringify(request)).then((result) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: request,\n                        response: result,\n                        provider: this\n                    });\n                    // For each result, feed it to the correct Promise, depending\n                    // on whether it was a success or error\n                    batch.forEach((inflightRequest, index) => {\n                        const payload = result[index];\n                        if (payload.error) {\n                            const error = new Error(payload.error.message);\n                            error.code = payload.error.code;\n                            error.data = payload.error.data;\n                            inflightRequest.reject(error);\n                        }\n                        else {\n                            inflightRequest.resolve(payload.result);\n                        }\n                    });\n                }, (error) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: request,\n                        provider: this\n                    });\n                    batch.forEach((inflightRequest) => {\n                        inflightRequest.reject(error);\n                    });\n                });\n            }, 10);\n        }\n        return promise;\n    }\n}\n","/* istanbul ignore file */\n\"use strict\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n// Special API key provided by Nodesmith for ethers.js\nconst defaultApiKey = \"ETHERS_JS_SHARED\";\nexport class NodesmithProvider extends UrlJsonRpcProvider {\n    static getApiKey(apiKey) {\n        if (apiKey && typeof (apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey || defaultApiKey;\n    }\n    static getUrl(network, apiKey) {\n        logger.warn(\"NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.\");\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc\";\n                break;\n            case \"ropsten\":\n                host = \"https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc\";\n                break;\n            case \"rinkeby\":\n                host = \"https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc\";\n                break;\n            case \"goerli\":\n                host = \"https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc\";\n                break;\n            case \"kovan\":\n                host = \"https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return (host + \"?apiKey=\" + apiKey);\n    }\n}\n","\"use strict\";\nimport { getStatic } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n// These are load-balancer-based application IDs\nconst defaultApplicationIds = {\n    homestead: \"6004bcd10040261633ade990\",\n    ropsten: \"6004bd4d0040261633ade991\",\n    rinkeby: \"6004bda20040261633ade994\",\n    goerli: \"6004bd860040261633ade992\",\n};\nexport class PocketProvider extends UrlJsonRpcProvider {\n    constructor(network, apiKey) {\n        // We need a bit of creativity in the constructor because\n        // Pocket uses different default API keys based on the network\n        if (apiKey == null) {\n            const n = getStatic(new.target, \"getNetwork\")(network);\n            if (n) {\n                const applicationId = defaultApplicationIds[n.name];\n                if (applicationId) {\n                    apiKey = {\n                        applicationId: applicationId,\n                        loadBalancer: true\n                    };\n                }\n            }\n            // If there was any issue above, we don't know this network\n            if (apiKey == null) {\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n            }\n        }\n        super(network, apiKey);\n    }\n    static getApiKey(apiKey) {\n        // Most API Providers allow null to get the default configuration, but\n        // Pocket requires the network to decide the default provider, so we\n        // rely on hijacking the constructor to add a sensible default for us\n        if (apiKey == null) {\n            logger.throwArgumentError(\"PocketProvider.getApiKey does not support null apiKey\", \"apiKey\", apiKey);\n        }\n        const apiKeyObj = {\n            applicationId: null,\n            loadBalancer: false,\n            applicationSecretKey: null\n        };\n        // Parse applicationId and applicationSecretKey\n        if (typeof (apiKey) === \"string\") {\n            apiKeyObj.applicationId = apiKey;\n        }\n        else if (apiKey.applicationSecretKey != null) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"), \"applicationSecretKey requires an applicationId\", \"applicationId\", apiKey.applicationId);\n            logger.assertArgument((typeof (apiKey.applicationSecretKey) === \"string\"), \"invalid applicationSecretKey\", \"applicationSecretKey\", \"[REDACTED]\");\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n        }\n        else if (apiKey.applicationId) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"), \"apiKey.applicationId must be a string\", \"apiKey.applicationId\", apiKey.applicationId);\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n        }\n        else {\n            logger.throwArgumentError(\"unsupported PocketProvider apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKeyObj;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"homestead\":\n                host = \"eth-mainnet.gateway.pokt.network\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.gateway.pokt.network\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.gateway.pokt.network\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.gateway.pokt.network\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n        let url = null;\n        if (apiKey.loadBalancer) {\n            url = `https:/\\/${host}/v1/lb/${apiKey.applicationId}`;\n        }\n        else {\n            url = `https:/\\/${host}/v1/${apiKey.applicationId}`;\n        }\n        const connection = { url };\n        // Initialize empty headers\n        connection.headers = {};\n        // Apply application secret key\n        if (apiKey.applicationSecretKey != null) {\n            connection.user = \"\";\n            connection.password = apiKey.applicationSecretKey;\n        }\n        return connection;\n    }\n    isCommunityResource() {\n        return (this.applicationId === defaultApplicationIds[this.network.name]);\n    }\n}\n","\"use strict\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nlet _nextId = 1;\nfunction buildWeb3LegacyFetcher(provider, sendFunc) {\n    const fetcher = \"Web3LegacyFetcher\";\n    return function (method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (_nextId++),\n            jsonrpc: \"2.0\"\n        };\n        return new Promise((resolve, reject) => {\n            this.emit(\"debug\", {\n                action: \"request\",\n                fetcher,\n                request: deepCopy(request),\n                provider: this\n            });\n            sendFunc(request, (error, response) => {\n                if (error) {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        fetcher,\n                        error,\n                        request,\n                        provider: this\n                    });\n                    return reject(error);\n                }\n                this.emit(\"debug\", {\n                    action: \"response\",\n                    fetcher,\n                    request,\n                    response,\n                    provider: this\n                });\n                if (response.error) {\n                    const error = new Error(response.error.message);\n                    error.code = response.error.code;\n                    error.data = response.error.data;\n                    return reject(error);\n                }\n                resolve(response.result);\n            });\n        });\n    };\n}\nfunction buildEip1193Fetcher(provider) {\n    return function (method, params) {\n        if (params == null) {\n            params = [];\n        }\n        const request = { method, params };\n        this.emit(\"debug\", {\n            action: \"request\",\n            fetcher: \"Eip1193Fetcher\",\n            request: deepCopy(request),\n            provider: this\n        });\n        return provider.request(request).then((response) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                response,\n                provider: this\n            });\n            return response;\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                error,\n                provider: this\n            });\n            throw error;\n        });\n    };\n}\nexport class Web3Provider extends JsonRpcProvider {\n    constructor(provider, network) {\n        logger.checkNew(new.target, Web3Provider);\n        if (provider == null) {\n            logger.throwArgumentError(\"missing provider\", \"provider\", provider);\n        }\n        let path = null;\n        let jsonRpcFetchFunc = null;\n        let subprovider = null;\n        if (typeof (provider) === \"function\") {\n            path = \"unknown:\";\n            jsonRpcFetchFunc = provider;\n        }\n        else {\n            path = provider.host || provider.path || \"\";\n            if (!path && provider.isMetaMask) {\n                path = \"metamask\";\n            }\n            subprovider = provider;\n            if (provider.request) {\n                if (path === \"\") {\n                    path = \"eip-1193:\";\n                }\n                jsonRpcFetchFunc = buildEip1193Fetcher(provider);\n            }\n            else if (provider.sendAsync) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));\n            }\n            else if (provider.send) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));\n            }\n            else {\n                logger.throwArgumentError(\"unsupported provider\", \"provider\", provider);\n            }\n            if (!path) {\n                path = \"unknown:\";\n            }\n        }\n        super(path, network);\n        defineReadOnly(this, \"jsonRpcFetchFunc\", jsonRpcFetchFunc);\n        defineReadOnly(this, \"provider\", subprovider);\n    }\n    send(method, params) {\n        return this.jsonRpcFetchFunc(method, params);\n    }\n}\n","\"use strict\";\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { BaseProvider, Resolver } from \"./base-provider\";\nimport { AlchemyProvider, AlchemyWebSocketProvider } from \"./alchemy-provider\";\nimport { CloudflareProvider } from \"./cloudflare-provider\";\nimport { EtherscanProvider } from \"./etherscan-provider\";\nimport { FallbackProvider } from \"./fallback-provider\";\nimport { IpcProvider } from \"./ipc-provider\";\nimport { InfuraProvider, InfuraWebSocketProvider } from \"./infura-provider\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\nimport { JsonRpcBatchProvider } from \"./json-rpc-batch-provider\";\nimport { NodesmithProvider } from \"./nodesmith-provider\";\nimport { PocketProvider } from \"./pocket-provider\";\nimport { StaticJsonRpcProvider, UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Web3Provider } from \"./web3-provider\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { Formatter, isCommunityResourcable, isCommunityResource, showThrottleMessage } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n////////////////////////\n// Helper Functions\nfunction getDefaultProvider(network, options) {\n    if (network == null) {\n        network = \"homestead\";\n    }\n    // If passed a URL, figure out the right type of provider based on the scheme\n    if (typeof (network) === \"string\") {\n        // @TODO: Add support for IpcProvider; maybe if it ends in \".ipc\"?\n        // Handle http and ws (and their secure variants)\n        const match = network.match(/^(ws|http)s?:/i);\n        if (match) {\n            switch (match[1]) {\n                case \"http\":\n                    return new JsonRpcProvider(network);\n                case \"ws\":\n                    return new WebSocketProvider(network);\n                default:\n                    logger.throwArgumentError(\"unsupported URL scheme\", \"network\", network);\n            }\n        }\n    }\n    const n = getNetwork(network);\n    if (!n || !n._defaultProvider) {\n        logger.throwError(\"unsupported getDefaultProvider network\", Logger.errors.NETWORK_ERROR, {\n            operation: \"getDefaultProvider\",\n            network: network\n        });\n    }\n    return n._defaultProvider({\n        FallbackProvider,\n        AlchemyProvider,\n        CloudflareProvider,\n        EtherscanProvider,\n        InfuraProvider,\n        JsonRpcProvider,\n        NodesmithProvider,\n        PocketProvider,\n        Web3Provider,\n        IpcProvider,\n    }, options);\n}\n////////////////////////\n// Exports\nexport { \n// Abstract Providers (or Abstract-ish)\nProvider, BaseProvider, Resolver, UrlJsonRpcProvider, \n///////////////////////\n// Concrete Providers\nFallbackProvider, AlchemyProvider, AlchemyWebSocketProvider, CloudflareProvider, EtherscanProvider, InfuraProvider, InfuraWebSocketProvider, JsonRpcProvider, JsonRpcBatchProvider, NodesmithProvider, PocketProvider, StaticJsonRpcProvider, Web3Provider, WebSocketProvider, IpcProvider, \n///////////////////////\n// Signer\nJsonRpcSigner, \n///////////////////////\n// Functions\ngetDefaultProvider, getNetwork, isCommunityResource, isCommunityResourcable, showThrottleMessage, \n///////////////////////\n// Objects\nFormatter };\n","\"use strict\";\nimport hash from \"hash.js\";\n//const _ripemd160 = _hash.ripemd160;\nimport { arrayify } from \"@ethersproject/bytes\";\nimport { SupportedAlgorithm } from \"./types\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport function ripemd160(data) {\n    return \"0x\" + (hash.ripemd160().update(arrayify(data)).digest(\"hex\"));\n}\nexport function sha256(data) {\n    return \"0x\" + (hash.sha256().update(arrayify(data)).digest(\"hex\"));\n}\nexport function sha512(data) {\n    return \"0x\" + (hash.sha512().update(arrayify(data)).digest(\"hex\"));\n}\nexport function computeHmac(algorithm, key, data) {\n    if (!SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm \" + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n    return \"0x\" + hash.hmac(hash[algorithm], arrayify(key)).update(arrayify(data)).digest(\"hex\");\n}\n","export const version = \"sha2/5.5.0\";\n","export var SupportedAlgorithm;\n(function (SupportedAlgorithm) {\n    SupportedAlgorithm[\"sha256\"] = \"sha256\";\n    SupportedAlgorithm[\"sha512\"] = \"sha512\";\n})(SupportedAlgorithm || (SupportedAlgorithm = {}));\n;\n","'use strict'\nvar ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'\n\n// pre-compute lookup table\nvar ALPHABET_MAP = {}\nfor (var z = 0; z < ALPHABET.length; z++) {\n  var x = ALPHABET.charAt(z)\n\n  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')\n  ALPHABET_MAP[x] = z\n}\n\nfunction polymodStep (pre) {\n  var b = pre >> 25\n  return ((pre & 0x1FFFFFF) << 5) ^\n    (-((b >> 0) & 1) & 0x3b6a57b2) ^\n    (-((b >> 1) & 1) & 0x26508e6d) ^\n    (-((b >> 2) & 1) & 0x1ea119fa) ^\n    (-((b >> 3) & 1) & 0x3d4233dd) ^\n    (-((b >> 4) & 1) & 0x2a1462b3)\n}\n\nfunction prefixChk (prefix) {\n  var chk = 1\n  for (var i = 0; i < prefix.length; ++i) {\n    var c = prefix.charCodeAt(i)\n    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')'\n\n    chk = polymodStep(chk) ^ (c >> 5)\n  }\n  chk = polymodStep(chk)\n\n  for (i = 0; i < prefix.length; ++i) {\n    var v = prefix.charCodeAt(i)\n    chk = polymodStep(chk) ^ (v & 0x1f)\n  }\n  return chk\n}\n\nfunction encode (prefix, words, LIMIT) {\n  LIMIT = LIMIT || 90\n  if ((prefix.length + 7 + words.length) > LIMIT) throw new TypeError('Exceeds length limit')\n\n  prefix = prefix.toLowerCase()\n\n  // determine chk mod\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') throw new Error(chk)\n\n  var result = prefix + '1'\n  for (var i = 0; i < words.length; ++i) {\n    var x = words[i]\n    if ((x >> 5) !== 0) throw new Error('Non 5-bit word')\n\n    chk = polymodStep(chk) ^ x\n    result += ALPHABET.charAt(x)\n  }\n\n  for (i = 0; i < 6; ++i) {\n    chk = polymodStep(chk)\n  }\n  chk ^= 1\n\n  for (i = 0; i < 6; ++i) {\n    var v = (chk >> ((5 - i) * 5)) & 0x1f\n    result += ALPHABET.charAt(v)\n  }\n\n  return result\n}\n\nfunction __decode (str, LIMIT) {\n  LIMIT = LIMIT || 90\n  if (str.length < 8) return str + ' too short'\n  if (str.length > LIMIT) return 'Exceeds length limit'\n\n  // don't allow mixed case\n  var lowered = str.toLowerCase()\n  var uppered = str.toUpperCase()\n  if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str\n  str = lowered\n\n  var split = str.lastIndexOf('1')\n  if (split === -1) return 'No separator character for ' + str\n  if (split === 0) return 'Missing prefix for ' + str\n\n  var prefix = str.slice(0, split)\n  var wordChars = str.slice(split + 1)\n  if (wordChars.length < 6) return 'Data too short'\n\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') return chk\n\n  var words = []\n  for (var i = 0; i < wordChars.length; ++i) {\n    var c = wordChars.charAt(i)\n    var v = ALPHABET_MAP[c]\n    if (v === undefined) return 'Unknown character ' + c\n    chk = polymodStep(chk) ^ v\n\n    // not in the checksum?\n    if (i + 6 >= wordChars.length) continue\n    words.push(v)\n  }\n\n  if (chk !== 1) return 'Invalid checksum for ' + str\n  return { prefix: prefix, words: words }\n}\n\nfunction decodeUnsafe () {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n}\n\nfunction decode (str) {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n\n  throw new Error(res)\n}\n\nfunction convert (data, inBits, outBits, pad) {\n  var value = 0\n  var bits = 0\n  var maxV = (1 << outBits) - 1\n\n  var result = []\n  for (var i = 0; i < data.length; ++i) {\n    value = (value << inBits) | data[i]\n    bits += inBits\n\n    while (bits >= outBits) {\n      bits -= outBits\n      result.push((value >> bits) & maxV)\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      result.push((value << (outBits - bits)) & maxV)\n    }\n  } else {\n    if (bits >= inBits) return 'Excess padding'\n    if ((value << (outBits - bits)) & maxV) return 'Non-zero padding'\n  }\n\n  return result\n}\n\nfunction toWordsUnsafe (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n}\n\nfunction toWords (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nfunction fromWordsUnsafe (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n}\n\nfunction fromWords (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nmodule.exports = {\n  decodeUnsafe: decodeUnsafe,\n  decode: decode,\n  encode: encode,\n  toWordsUnsafe: toWordsUnsafe,\n  toWords: toWords,\n  fromWordsUnsafe: fromWordsUnsafe,\n  fromWords: fromWords\n}\n"],"names":["BaseX","alphabet","defineReadOnly","this","length","charAt","i","_alphabetMap","value","source","arrayify","digits","carry","j","base","push","string","k","_leader","q","TypeError","bytes","Uint8Array","byte","undefined","Error","reverse","Base58","version","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","result","done","then","apply","logger","Logger","padding","fill","NegativeOne","BigNumber","Zero","One","MaxUint256","hexTrue","hexZeroPad","toHexString","hexFalse","domainFieldTypes","name","chainId","verifyingContract","salt","domainFieldNames","checkString","key","throwArgumentError","JSON","stringify","domainChecks","toString","error","getAddress","toLowerCase","hexlify","getBaseEncoder","type","match","signed","width","parseInt","String","boundsUpper","mask","boundsLower","add","mul","v","lt","gt","toTwos","padOffset","hexConcat","slice","hexPadRight","keccak256","id","encodeType","fields","map","join","TypedDataEncoder","types","Object","freeze","deepCopy","links","parents","subtypes","keys","forEach","uniqueNames","field","baseType","primaryTypes","filter","n","t","checkCircular","found","child","subtype","primaryType","st","sort","_types","encoder","_encoderCache","_getEncoder","subEncoder","getEncoder","encodedType","values","unshift","encodeData","hashStruct","callback","_visit","reduce","accum","from","domain","domainFields","a","b","indexOf","EIP712Domain","hashDomain","hash","encode","resolveName","shallowCopy","ensCache","isHexString","visit","domainValues","domainTypes","typesWithDomain","message","ethDefaultProvider","network","func","providers","options","providerList","InfuraProvider","infura","EtherscanProvider","etherscan","AlchemyProvider","alchemy","PocketProvider","provider","CloudflareProvider","FallbackProvider","quorum","renetwork","etcDefaultProvider","url","JsonRpcProvider","homestead","ensAddress","_defaultProvider","ropsten","classicMordor","networks","unspecified","mainnet","morden","testnet","rinkeby","kovan","goerli","kintsugi","classic","classicMorden","classicTestnet","classicKotti","xdai","matic","maticmum","optimism","arbitrum","bnb","bnbt","getNetwork","standard","defaultProvider","createTable","data","lo","split","pair","comps","createRangeTable","hi","l","h","matchMap","ranges","range","d","Table_A_1_ranges","Table_B_1_flags","Table_B_2_ranges","s","Table_B_2_lut_abs","Table_B_2_lut_rel","Table_B_2_complex","substring","Table_C_ranges","nameprep","codes","toUtf8CodePoints","code","codesTableB2","codepoint","shift","_nameprepTableB2","_toUtf8String","UnicodeNormalizationForm","Zeros","Partition","RegExp","namehash","current","partition","label","toUtf8Bytes","concat","decode","textData","atob","charCodeAt","fromCharCode","btoa","getUrl","href","request","method","headers","body","skipFetchSetup","mode","cache","credentials","redirect","referrer","fetch","response","arrayBuffer","get","statusCode","status","statusMessage","statusText","staller","duration","setTimeout","bodyify","isBytesLike","trim","toUtf8String","fetchJson","connection","json","processFunc","updated","attemptLimit","throttleLimit","assertArgument","throttleCallback","throttleSlotInterval","allow304","timeout","allowGzip","user","password","allowInsecureAuthentication","throwError","argument","authorization","base64Encode","reData","dataMatch","base64Decode","requestBody","requestMethod","flatHeaders","header","runningTimeout","timer","promise","makeError","cancel","clearTimeout","runningFetch","attempt","location","tryAgain","stall","retryAfter","Math","random","pow","serverError","throttleRetry","race","_fetchData","parse","poll","floor","ceiling","interval","retryLimit","check","oncePoll","once","onceBlock","Formatter","checkNew","formats","getDefaultFormats","address","bind","bigNumber","blockTag","hex","number","transaction","accessList","allowNull","blockHash","blockNumber","transactionIndex","confirmations","gasPrice","maxPriorityFeePerGas","maxFeePerGas","gasLimit","to","nonce","r","uint256","creates","raw","transactionRequest","receiptLog","transactionHash","topics","arrayOf","logIndex","receipt","contractAddress","root","gasUsed","logsBloom","logs","cumulativeGasUsed","effectiveGasPrice","block","parentHash","timestamp","difficulty","miner","extraData","transactions","baseFeePerGas","blockWithTransactions","transactionResponse","fromBlock","toBlock","filterLog","removed","boolean","allowFalsish","accessListify","toNumber","strict","hexDataSlice","getContractAddress","hexValue","hexDataLength","format","author","_difficulty","_block","gas","isZero","input","networkId","replace","parseTransaction","byzantium","Array","isArray","object","checkKey","checkValue","nullValue","replaceValue","array","isCommunityResourcable","isCommunityResource","throttleMessage","showThrottleMessage","console","log","checkTopic","topic","serializeTopics","pop","unique","sorted","getEventTag","eventName","ForkEvent","warn","getTime","Date","PollableEvents","Event","tag","listener","coinInfos","symbol","p2pkh","p2sh","prefix","ilk","bytes32ify","base58Encode","sha256","matcherIpfs","matchers","_parseString","_parseBytes","offset","getIpfsLink","link","Resolver","resolvedAddress","formatter","selector","parameters","tx","call","coinType","hexBytes","coinInfo","operation","words","bech32","callAddress","_fetchBytes","_getAddress","linkage","content","getText","avatar","scheme","_resolvedAddress","owner","addr","tokenId","tokenOwner","balance","metadataUrl","metadata","imageUrl","image","ipfs","swarm","keyBytes","defaultFormatter","nextPollId","BaseProvider","Provider","_events","_emitted","getFormatter","anyNetwork","detectNetwork","_networkPromise","catch","_ready","knownNetwork","getStatic","emit","_maxInternalBlockNumber","_lastBlockNumber","_pollingInterval","_fastQueryDate","_network","event","maxAge","_internalBlockNumber","internalBlockNumber","respTime","reqTime","checkInternalBlockNumber","resolveProperties","perform","networkError","_setFastBlockNumber","pollId","runners","_getInternalBlockNumber","pollingInterval","abs","previousBlockNumber","eventBlockNumber","runner","getTransactionReceipt","getLogs","all","polling","currentNetwork","_fastBlockNumber","_fastBlockNumberPromise","detectedNetwork","_poller","setInterval","_bootstrapPoll","clearInterval","now","getBlockNumber","_waitForTransaction","replaceable","cancelFuncs","alreadyDone","minedHandler","on","removeListener","lastBlockNumber","startBlock","scannedBlock","replaceHandler","getTransactionCount","getTransaction","mined","getBlockWithTransactions","ti","waitForTransaction","reason","eq","cancelled","replacement","_wrapTransaction","unref","addressOrName","_getBlockTag","params","position","p","expectedHash","returnedHash","wait","confirms","signedTransaction","hexTx","_getTransactionRequest","blockHashOrBlockTag","includeTransactions","blockWithTxs","_getBlock","_getFilter","_getResolver","getResolver","resolver","reverseName","resolverAddress","nameOrAddress","getAvatar","pollable","_startEvent","_addEventListener","args","stopped","eventTag","_stopEvent","removeAllListeners","errorGas","checkError","responseText","getResult","payload","getLowerCase","_constructorGuard","JsonRpcSigner","constructorGuard","addressOrIndex","UncheckedJsonRpcSigner","_address","_index","send","accounts","fromAddress","estimate","estimateGas","sender","constructor","hexlifyTransaction","sendUncheckedTransaction","_TypedDataEncoder","populated","Signer","allowedTransactionKeys","networkOrReady","_nextId","_eventLoopCache","_cache","_uncachedDetectNetwork","getSigner","connectUnchecked","jsonrpc","action","getFeeData","feeData","prepareRequest","_startPending","_pendingFilter","self","pendingFilter","filterId","hashes","seq","listenerCount","allowExtra","allowed","checkProperties","WS","WebSocket","NextId","WebSocketProvider","_wsReady","_websocket","onopen","_requests","onmessage","messageEvent","sub","_subs","subscription","fauxPoll","_detectNetwork","rid","param","subIdPromise","_subIds","subId","_subscribe","emitReceipt","readyState","onerror","close","StaticJsonRpcProvider","_super","create","UrlJsonRpcProvider","apiKey","checkAbstract","defaultApiKey","AlchemyWebSocketProvider","host","arguments","getTransactionPostData","maxFeePerGs","set","storageKeys","getJsonResult","checkLogTag","getBaseUrl","module","query","baseUrl","apikey","post","getPostUrl","getPostData","procFunc","payloadStr","txhash","postData","topic0","blocks","getBlock","parseFloat","ethusd","endBlock","startblock","endblock","item","timeStamp","shuffled","tmp","checkNetworks","median","maxDelta","middle","serialize","nextRid","getPromise","ForwardErrors","ForwardProperties","exposeDebugConfig","config","weight","defineProperty","start","getProcessFunc","normalize","configs","c","ceil","_highestBlockNumber","tally","count","normalizedTally","waitForSync","getRunner","currentBlockNumber","getEtherPrice","getStorageAt","providerConfigs","configOrProvider","index","stallTimeout","priority","total","sendTransaction","results","first","t0","inflightWeight","backend","waiting","errors","errorCode","props","IpcProvider","defaultProjectId","InfuraWebSocketProvider","projectId","projectSecret","apiKeyObj","JsonRpcBatchProvider","_pendingBatch","inflightRequest","_pendingBatchAggregator","batch","inflight","NodesmithProvider","defaultApplicationIds","applicationId","loadBalancer","applicationSecretKey","buildWeb3LegacyFetcher","sendFunc","fetcher","Web3Provider","path","jsonRpcFetchFunc","subprovider","isMetaMask","buildEip1193Fetcher","sendAsync","getDefaultProvider","ripemd160","update","digest","computeHmac","algorithm","SupportedAlgorithm","ALPHABET","ALPHABET_MAP","z","x","polymodStep","pre","prefixChk","chk","__decode","str","LIMIT","lowered","uppered","toUpperCase","lastIndexOf","wordChars","convert","inBits","outBits","pad","bits","maxV","exports","decodeUnsafe","res","toWordsUnsafe","toWords","fromWordsUnsafe","fromWords"],"sourceRoot":""}